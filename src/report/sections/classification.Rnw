<<message=FALSE>>=
require(GenomicRanges)
require(Biostrings)
require(ggplot2)
require(reshape2)
require(scales)
require(dplyr)
require(xtable)
@

<<results, message=FALSE, warning=FALSE, cache=TRUE>>=
# TODO: check all inputs, and handle missing files appropriately

# TODO: the ranges for GFFs and SI are off by 1, e.g.
# $ target$si$query[1]
# $ query$gff[which(query$gff$seqid == target$si$query[1]$seqid)]

# TODO: in Arabidopsis lyrata, at least, there are out of bound intervals

source('~/src/git/cadmium/src/report/R/classification.R')
source('~/src/git/cadmium/src/report/R/loadData.R')
source('~/src/git/cadmium/src/report/R/indels.R')
source('~/src/git/cadmium/src/report/R/syntenic_stats.R')
source('~/src/git/cadmium/src/report/R/sequence_alignments.R')
source('~/src/git/cadmium/src/report/R/feature_overlaps.R')
require(tidyr)
require(dplyr)

config <- LoadConfig(configfile='~/src/git/cadmium/cadmium.cfg')

l_seqinfo <- LoadSeqinfoList(config)

query.cache <- sprintf('%s/query.Rdat', config$d_cache)
if(file.exists(query.cache)){
  load(query.cache)
} else {
  query <- LoadQuery(config, l_seqinfo)
  save(query, file=query.cache)
}

results.cache <- sprintf('%s/results.Rdat', config$d_cache)
if(file.exists(results.cache)){
  load(results.cache)
} else {
  results <- list()
  for(s in config$species){
    if(s %in% c(config$focal_species)){
      next
    }
    results[[s]] <- getTargetResults(
      species   = s,
      query     = query,
      config    = config,
      l_seqinfo = l_seqinfo,
      use_cache = TRUE
    )
  }
  save(results, file=results.cache)
}

labels <- determineLabels(query, results, config)

origin <- determineOrigins(labels, config)
@

\subsection{Data input}

\begin{figure}[!ht]
    \centering
<<cache=TRUE, message=FALSE>>=
lapply(
  results,
  function(x){
    syn <- x$syn
    lograt <- log2(width(syn$query) / width(syn$target)[syn$query$over])
    lograt <- lograt[abs(lograt) > 0.25] 
    data.frame(
      lograt=lograt,
      index=1:length(lograt)
    )
  }
) %>% melt(id.vars=c('lograt', 'index')) %>% dplyr::rename(species=L1) %>%
ggplot +
  geom_point(aes(x=index, y=lograt), size=0.2) +
  xlab('Ordered position on query genome') +
  ylab('log2 of query to target length ratio') +
  facet_wrap(~species, scale='free_x')
@
    \caption{\textbf{Diagnostic plot of query to target lengths in synteny
        map}. The syntenic intervals on the query and target sides should
        be of similar length.  They will not be exactly the same size if gaps
        are allowed in the alignment, but wild deviation from 0 (more than,
        say, 2) indicates errors in the input. To avoid overplotting, values
        between -0.25 and 0.25 are not plotted.} 
\end{figure}



\subsection{Search interval overview}

Syntenic flags:

\begin{description}
  \item[0] the search interval is reliable
  \item[1] the start edge is unreliable
  \item[2] the stop edge is unreliable
  \item[3] both edges are unreliable, but there is an overlap
  \item[4] neither edge of the search interval is reliable
\end{description}

<<message=FALSE, cache=TRUE>>=
m <- lapply(results, function(x) x$synteny$bittbl) %>%
  lapply(dplyr::rename, orphan=orp_prop, non_orphan=non_orp_prop) %>%
  melt(id.vars='bit', value.name='proportion', variable.name='class') %>%
  subset(class %in% c('orphan', 'non_orphan')) %>%
  dplyr::rename(species=L1)
@
\begin{figure}[!ht]
    \centering
<<message=FALSE, cache=TRUE>>=
ggplot(m) +
    geom_line(aes(x=bit, y=proportion, group=class)) +
    geom_point(aes(x=bit, y=proportion, color=class)) +
    xlab('Synteny flags') +
    ylab('Proportion') +
    theme(
        axis.text.x = element_text(angle=270, hjust=0, vjust=1),
        legend.position=c(1, 1),
        legend.justification=c(1, 1)
    ) +
    facet_wrap(~species)
@
  \caption{\textbf{Synteny flags}. \textbf{(0)} the search interval is reliable;
    \textbf{(1)} the start edge is unreliable; \textbf{(2)} the stop edge is
    unreliable; \textbf{(3)} edges are unreliable, but there is overlap;
    \textbf{(4)} syntenically unreliable}.
  \label{fig:synflags}
\end{figure}
<<results='asis', cache=TRUE>>=
m %>%
  dplyr::mutate(proportion = signif(proportion * 100, 2)) %>%
  dcast(class + bit ~ species, mean, value.var='proportion') %>%
  xtable(caption=sprintf('Percent of genes in each syntenic class.'))
@

\begin{figure}[!ht]
  \centering
<<cache=TRUE, message=FALSE>>=
lapply(results, function(x) x$synteny$flags) %>%
  lapply(function(x) mutate(x, seqid=rownames(x))) %>%
  melt(id.vars='seqid') %>%
  dplyr::mutate(
    size = width(query$aa[seqid]),
    orph = ifelse(seqid %in% query$orphans, 'orphan', 'non-orphan')
  ) %>%
  dplyr::rename(flag=variable, species=L1) %>%
  subset(value > 0) %>%
  ggplot(aes(x=flag, y=size)) +
    geom_boxplot(width=0.5, notch=TRUE, outlier.size=0) +
    geom_violin(alpha=0.3) +
    facet_grid(species~orph) +
    scale_y_continuous(
      trans='log2',
      breaks=trans_breaks('log2', function(x) round(2^x))
    )
@
  \caption{\textbf{Length of genes versus syntenic flag}. Is their a
    relationship between flag class and gene length? It is reasonable that
    their would be. For example, a short interval would be less likely to be
    interupted. If the plots above suggest a meaningful difference, further
    quantitative studies may be warranted.}
  \label{fig:flag-vs-length}
\end{figure}



\subsection{Mapping features between GFF given scaffold}


% ----------------------
% summarize CDS overlaps
% ----------------------

% \begin{figure}[!ht]
%     \centering
% <<fig.width=6, fig.height=4, message=FALSE, cache=TRUE>>=
% # featureCountTable <- function(feat){
% #   lapply(feat$overlaps, length) %>% 
% #       unlist %>% factor %>% summary(maxsum=Inf) %>%
% #       data.frame(.) %>%
% #       set_names('Count')
% # }
%
% # TODO: rewrite this with 
% lapply(results, function(x) x$features$CDS) %>%
%   melt %>%
%   dplyr::rename(species=L1) %>%
%   # TODO: convert target to CDS count
%   count(query, species) %>%
%   dplyr::rename(N.cds=n) %>%
%   count(species, N.cds)
%
%
%   featureCountTable(x$features$CDS) %>%
%     {data.frame(
%       N.cds=as.numeric(row.names(.)),
%       count=.$Count)
%     }
%   %>% melt(id.vars=c('N.cds', 'count')) %>% dplyr::rename(species=L1) %>%
%   ggplot +
%     geom_point(aes(x=N.cds, y=count), size=0.2) +
%     xlab('Number of overlapped CDSs') +
%     ylab('Number of search intervals') +
%     scale_y_continuous(
%       trans='log2',
%       breaks=trans_breaks('log2', function(x) round(2^x))
%     ) +
%     facet_wrap(~species)
% @
%   \caption{Number of CDS's overlapped by a single search interval}.
% \end{figure}


% -----------------------
% summarize mRNA overlaps
% -----------------------
\begin{figure}[!ht]
  \centering
<<fig.width=6, fig.height=4, message=FALSE, cache=TRUE>>=
require(tidyr)

m <- lapply(results, function(x) x$features) %>%
    melt(id.vars=c('query', 'target'), level=2) %>%
    dplyr::rename(species=L2, type=L3) %>%
    filter(type %in% c('CDS', 'mRNA', 'gene')) %>%
    count(query, species, type) %>%
    dplyr::rename(n.feature=n) %>%
    count(species, type, n.feature)
m.zero <- m %>%
  group_by(species, type) %>%
  summarize(n=sum(n)) %>%
  mutate(
    n.feature = 0,
    n = length(query$aa) - n
  )
m2 <- rbind(m, m.zero)

ggplot(m2) +
  geom_point(aes(x=n.feature, y=n), size=0.2) +
  geom_line(aes(x=n.feature, y=n), alpha=0.05) +
  xlab('Number of overlapped mRNAs') +
  ylab('Number of search intervals') +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  ) +
  facet_grid(type~species)

@
  \caption{Number of target mRNAs overlapping one search interval}
\end{figure}


% --------------------------------------
% summarize mRNA and CDS in common table
% --------------------------------------
<<results='asis', cache=TRUE>>=
merge(
  results %>%
    lapply(function(x) x$features$CDS$query) %>%
    lapply(unique) %>%
    lapply(length) %>%
    melt %>%
    dplyr::rename(CDS=value, species=L1),
  results %>%
    lapply(function(x) x$features$mRNA$query) %>%
    lapply(unique) %>%
    lapply(function(x) sum(x %in% query$orphans)) %>%
    melt %>%
    dplyr::rename(mRNA=value, species=L1)
) %>% xtable(caption='Number of orphans with search intervals overlapping given features')
@

\subsection{Find indel events}

<<results='asis', cache=TRUE>>=
results %>%
  lapply(function(x) x$ind.stats[1:2]) %>%
  melt %>%
  dplyr::rename(seqid=value, group=L2, species=L1) %>%
  dplyr::mutate(
    orphan = ifelse(seqid %in% query$orphans, 'orp', 'old'),
    group = sub('.queries', '', group)
  ) %>%
  dplyr::count(group, species, orphan) %>%
  dcast(species ~ group + orphan, mean, value.var='n') %>%
  dplyr::arrange(indeled_old, resized_old, indeled_orp, resized_orp) %>%
  dplyr::rename(
    ind_old=indeled_old, ind_orp=indeled_orp,
    res_old=resized_old, res_orp=resized_orp
  ) %>%
  xtable(
    display=c('s', 's', 'd', 'd', 'd', 'd'), 
    caption=
      'Summary of indel and resize events. A query is classified as indeled if at
      least one search interval is less than 5\\% of the length of the query. A
      query classified as resized if at least one search interval is between 5\\%
      and 100\\% the size of the query. Resize and indel events are only considered
      if the search interval is bounded (flag == 0), in which case the search
      interval length upper bounds the length of any contained homolog.'
  )
@
% At least in the Arabidopsis thaliana versus Arabidopsis lyrata, all indel and
% resize events occur in no more than one search interval for a given query. In
% \Sexpr{length(q.res)} cases, the gene maps to only 1 search interval and is
% resized in it. Similarly for the \Sexpr{length(q.ind)} cases of indels. There
% are \Sexpr{nrow(d.irr)} cases where a gene maps to multiple search intervals,
% but still, only one of them is reduced or resized.

\subsection{Find queries overlapping N-strings}

<<results='asis', cache=TRUE>>=
results %>%
  lapply(function(x) unique(x$query2gap$query)) %>%
  melt %>%
  dplyr::mutate(
    orphan = ifelse(value %in% query$orphans, 'orphan', 'non-orphan')
  ) %>%
  dplyr::rename(species=L1) %>%
  dplyr::count(species, orphan) %>%
  dcast(species ~ orphan, mean, value.var='n') %>%
  xtable(
    display=c('s', 's', 'd', 'd'),
    caption=
    'The number of query genes for which at least one search interval overlaps
    at least one string of Ns (unknown bases) in the target genome. These genes
    could potentially be missed in sequence searches if the target homologs are
    inside these missing regions. NOTE: it cannot be assumed that the length of
    the N-string is equal to the length of the unknown region; the true unknown
    region length is often unknown, so a stretch of 100 Ns is often inserted to
    represent the gap of unknown length.'
  )
@

\subsection{Find protein matches}

\begin{figure}[!ht]
  \centering
<<message=FALSE, cache=TRUE>>=

m <- results %>% 
  lapply(function(x) x$prot2prot[c('query', 'score')]) %>%
  melt(id.vars=c('query', 'score')) %>%
  dplyr::rename(species=L1) %>%
  dplyr::mutate(orphan = (query %in% query$orphans))

ggplot() +
  geom_violin(
    mapping=aes(x=species, y=score),
    data=m,
    alpha=0.3
  ) +
  geom_point(
    mapping=aes(x=species, y=score, color=orphan),
    data=subset(m, score > 64 & orphan) %>%
         dplyr::group_by(query, species) %>%
         dplyr::summarize(score=max(score)) %>%
         as.data.frame,
    position=position_jitter(width=0.3),
    color='red'
  ) +
  xlab('Raw alignment score (BLOSUM80)') +
  theme(
    axis.text.x = element_text(angle=325, hjust=0, vjust=1)
  ) +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  )

@
  \caption{\
    Non-orphan genes are expected to have at a highscoring homolog, so there
    should be many high scoring hits. There should also be many low scoring
    ones, from the searches against genes that overlap the search interval but
    are not homologous. \textbf{In red:} the orphan genes with scores above 64
    against genic targets within their search intervals.
  }
\end{figure}

<<results='asis', cache=TRUE>>=
m %>%
  subset(score > 64) %>%
  dplyr::mutate(orphan = ifelse(orphan, 'orphan', 'non-orphan') %>% factor) %>%
  count(species, orphan) %>%
  xtable(
    caption='The number of query orphans and non-orphans with significant
    ($score > 64$) similarity to annotated genes in each target genome.'
  )
@
% <<>>=
% m <- data.frame(
%   group = c(rep('Ortholog', length(s.orth)),
%             rep('Overlapping', length(s.over)+1)),
%   N = c(names(s.orth), '0', names(s.over)) %>% as.integer,
%   count = c(s.orth, n.missing, s.over)
% )
% @
% <<results='asis'>>=
% require(xtable)
% m %>% xtable(caption=sprintf(
%  '\\textbf{Ortholog}: the number of query genes (count) where N target genes
%  both overlap a search interval AND have a high protein sequence similarity
%  score.  \\textbf{Overlapping}: the number of query genes (count) where N
%  target genes overlap a search interval.  %s\\%% of query genes have overlaps
%  and %s\\%% have identified orthologs.', perc.with.over, perc.with.orth))
% @

\subsection{Detect protein hit to ORF}

\begin{figure}[!ht]
  \centering
<<message=FALSE, cache=TRUE>>=
m <- results %>% 
  lapply(function(x) x$orfmap[c('query', 'score')]) %>%
  melt(id.vars=c('query', 'score')) %>%
  dplyr::rename(species=L1)
ggplot(m) +
  geom_violin(
    mapping=aes(x=species, y=score),
    data=m,
    alpha=0.3
  ) +
  geom_point(
    mapping=aes(x=species, y=score),
    data=subset(m, score > 64),
    position=position_jitter(width=0.8),
    alpha=0.3
  ) +
  theme(
    axis.text.x = element_text(angle=325, hjust=0, vjust=1)
  ) +
  xlab('Raw alignment score (BLOSUM80)') +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  )
@
  \caption{
    \textbf{Orphan genes hits against target ORFs}. All START/STOP bound open
    reading frames in the target genome were extracted. All orphan proteins
    were aligned against the ORFs that overlap one of their search intervals.
    Dots correspond to hits above 64.
  }
\end{figure}


\subsection{Find DNA hit}

\begin{figure}[!ht]
  \centering
<<message=FALSE, warning=FALSE, cache=TRUE>>=
m <- results %>%
  lapply(function(x) x$orp2dna) %>%
  melt(id.vars=c('score', 'qwidth', 'twidth', 'seqid')) %>%
  dplyr::rename(group=L2, species=L1)

ggplot(m) +
  geom_violin(
    mapping=aes(x=species, y=score),
    data=m,
    alpha=0.3
  ) +
  geom_point(
    mapping=aes(x=species, y=score),
    data=subset(m, score > 64),
    position=position_jitter(width=1),
    alpha=0.2
  ) +
  xlab('Raw alignment score (BLOSUM80)') +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  ) +
  coord_flip() +
  facet_grid(group~.)
@
\caption{\
  Scores of orphan genes against their search intervals. In \textbf{ctrl}, the
  starting positions of the orphan genes were permuted while preserving their
  gene length. By chance, a few of these permuted indices may start on their
  original place, so there will be a few highscoring values.
}
\end{figure}

\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
m %>%
  group_by(seqid, group, species) %>%
  summarize(
    score=max(score),
    qwidth=max(qwidth),
    twidth=max(twidth)
  ) %>%
  dplyr::mutate(signif=score > 64) %>%
  ggplot +
      geom_point(
        aes(
          x=qwidth,
          y=twidth,
          color=signif,
          size=score
        ),
        alpha=0.5
      ) +
      xlab('Query gene width') +
      ylab('Target search interval width') +
      facet_wrap(~species) +
      scale_x_continuous(
        trans='log2',
        breaks=trans_breaks('log2', function(x) round(2^x))
      ) +
      scale_y_continuous(
        trans='log2',
        breaks=trans_breaks('log2', function(x) round(2^x))
      )
@
\caption{\
  \textbf{Query gene length versus target search interval length}. The size of
  the points is proportional to score of the gene's best hit. A hit is
  considered significant if it is above a certain threshold (64 bits for now).
}
\end{figure}

\subsection{Leaf labels}

<<results='asis', cache=TRUE>>=
labels$summary %>% xtable
@

\begin{figure}[!ht]
  \centering
<<>>=
ggplot(labels$summary, aes(description, count)) +
  geom_bar(aes(fill=species), stat='identity', position='dodge') +
  coord_flip()
@
  \label{fig:}
\end{figure}

\begin{description}
  \item[CLASS 1: Genic]
    \begin{description}

      \item[known gene] Query has strong protein sequence similarity to a known
        target protein in the search interval.

      \item[unknown ORF off known mRNA] Query has strong protein sequence
        similarity to an unannotated open reading frame (ORF), bound by a STOP
        and START codon, that is in the search interval but that is NOT on a
        region known to be transcribed.

      \item[unknown ORF on known mRNA] Query has strong protein sequence
        similarity to an unannotated ORF on a spliced mRNA (but does not match
        a known genic ORF).

    \end{description}
  \item[CLASS 2: Non-genic]
    \begin{description}

      \item[CDS in SI] One of more known coding sequences (CDS) are in the
        search interval, but there is no predicted protein sequence similarity.

      \item[mRNA but not CDS in SI] One of more transcribed regions are in the
        search interval, but no CDS.

      \item[no gene in SI] No annotated coding genes are within the search interval.

      % \item[Intergenic] Query maps to no mRNAs and ALL search intervals are
      %   bounded. The query overlaps no \textit{annotated} target gene.
      %
      % \item[Possible-intergenic] Query maps to no mRNAs, but one or more search
      %   intervals is unbounded.

    \end{description}
  \item[CLASS 3: Unknown]
    \begin{description}

      \item[possible indel] Query maps to bounded search interval that is less
        than 5\% the query search interval length. AND the query maps to no other
        intervals.

      \item[possible N-string] The gene is of unknown origin and overlaps an
        unassembled regions (N-string).

      \item[possible resized] Query maps to bounded search interval that is
        5-100\% the query length. AND the query maps to no other intervals.
        These could correspond to indels, or expansions in the query search
        interval. I distinguish between resized and indeled because by the most
        common case where the search interval is smaller than the query is a
        full deletion, where the search interval length is 0. The 5\% cutoff is
        just to allow for inaccuracies in alignment. The true deletions have
        such a strong. My gerrymandering of the target intervals has obfuscated
        the query/target relation, I may need to rethink this.

      \item[syntenically scrambled] The query maps to target intervals that are
        unbounded and unanchored. Error in our search space estimates is a
        likely cause for not identifying the gene.

      \item[unknown] The synteny is reliable and there is no evidence of
        indels, but there is no sequence similarity of any sort to any of the
        search intervals. This could be caused be mutation completely past
        detectability, or by undetected deletions, or by transposition of the
        gene to a new context.

    \end{description}

\end{description}

\subsection{Final Classifications}

\begin{table}[!ht]
  \centering
  \begin{tabular}{| l | c c c |}
    \hline
    leaf states & gen & non & unk \\
    \hline
    gen gen & 1 & 0 & 0 \\
    gen non & 1 & 0 & 0 \\
    gen unk & 1 & 0 & 0 \\
    non non & 0 & 1 & 0 \\
    non unk & 0 & 0 & 1 \\
    unk unk & 0 & 0 & 1 \\
    \hline
  \end{tabular}

  \caption{Inference of parent based on child leaves. Assumes a bifurcating
    tree. \textbf{gen} is genic, \textbf{non} is non-genic, and \textbf{unk} is
    unknown. 1 and 0 are ancestor asignments, e.g. if the leafs are 'gen' and
    'gen', the ancestor is classified as 'gen' (as in column 1 row 1).}

  \label{tab:label}
\end{table}

<<>>=
print(origin$root, 'gen', 'non', 'unk')
@

<<results='asis'>>=
origin$final_class %>%
  count(class) %>%
  xtable(caption='Counts of primaries labels in youngest to oldest strata')
@
