<<message=FALSE, warning=FALSE>>=
source('~/src/git/cadmium/src/report/R/classification.R')
source('~/src/git/cadmium/src/report/R/loadData.R')
source('~/src/git/cadmium/src/report/R/indels.R')
source('~/src/git/cadmium/src/report/R/syntenic_stats.R')
source('~/src/git/cadmium/src/report/R/sequence_alignments.R')
source('~/src/git/cadmium/src/report/R/feature_overlaps.R')

config <- LoadConfig(configfile='~/src/git/cadmium/cadmium.cfg')

l_seqinfo <- LoadSeqinfoList(config)

# TODO: check all inputs, and handle missing files appropriately

query <- LoadQuery(config, l_seqinfo)

use_cache = TRUE

results <- list()
for(s in config$species){
  if(s %in% c(config$focal_species, 'Brassica_rapa')){
    next
  }

  cache <- function(x, ...){
    if(!dir.exists(config$d_cache)){
      dir.create(config$d_cache)
    }
    filename <- sprintf(
      '%s/%s.vs.%s-%s.Rdat',
      config$d_cache, config$focal_species, s, deparse(substitute(x))
    )
    if(file.exists(filename) && use_cache){
      load(filename)
    } else {
      out <- x(...)
      if(use_cache){
        save(out, file=filename)
      }
    }
    out
  }

  # TODO: Fix the out-of-range bugs
  target <- cache(LoadTarget, species=s, config=config, l_seqinfo=l_seqinfo)

  sflags <- cache(summarize.flags, target$si)

  origins <- initializeOrigins(query, target)

  # B1 - Queries of scrambled origin
  origins <- cache(syntenicState, origins, sflags)

  bittbl <- getBitTable(origins)

  # B2 - Queries overlap an indel in a target SI
  ind       <- cache(findIndels, target, indel.threshold=0.05)
  ind.stats <- indelStats(ind)
  ind.sumar <- indelSummaries(ind)

  overlapping.features <- cache(analyzeTargetFeature, query, target)
  # B3 - Queries whose SI overlap an mRNA
  fo.mrna <- overlapping.features$mRNA
  # B4 - Queries whose SI overlap a CDS
  fo.cds <- overlapping.features$CDS

  # B5 - Queries whose SI overlap an N-string
  query2gap <- cache(findQueryGaps, nstring=target$nstring, target=target)

  results[[s]] <- list(
    species=s,
    target=target,
    sflags=sflags,
    origins=origins,
    bittbl=bittbl,
    fo.mrna=fo.mrna,
    fo.cds=fo.cds,
    query2gap=query2gap
  )

  # # B6 - Queries whose protein seq matches a target protein in the SI
  # aln       <- cache(AA_aln, map=fo.cds$query2target, query=query, target=target)
  # aln.stats <- AA_aln_stats(aln, query)
  #
  # # B7 - Queries whose protein matches an ORF in an SI
  # query2orf <- cache(get_query2orf, target) 
  # orfmap    <- get_orfmap(query2orf, query, target)
  #
  # # B8 - Queries whose gene matches (DNA-DNA) an SI 
  # orp2dna <- cache(get_orphan_dna_hits, query, target)
  #
  # orp.origins <- determineLabels(origins, fo.cds, fo.mrna, aln, query2gap, ind.stats, orfmap, orp2dna)
}
@

\subsection{Data input}

\begin{figure}[!ht]
    \centering
<<cache=TRUE>>=
require(reshape2)
require(ggplot2)
lapply(
  results,
  function(x){
    syn <- x$target$syn
    lograt <- log2(width(syn$query) / width(syn$target)[syn$query$over])
    lograt <- lograt[abs(lograt) > 0.25] 
    data.frame(
      lograt=lograt,
      index=1:length(lograt)
    )
  }
) %>% melt(id.vars=c('lograt', 'index')) %>% dplyr::rename(species=L1) %>%
ggplot +
  geom_point(aes(x=index, y=lograt), size=0.2) +
  xlab('Ordered position on query genome') +
  ylab('log2 of query to target length ratio') +
  facet_wrap(~species, scale='free_x')
@
    \caption{\textbf{Diagnostic plot of query to target lengths in synteny
        map}. The syntenic intervals on the query and target sides should
        be of similar length.  They will not be exactly the same size if gaps
        are allowed in the alignment, but wild deviation from 0 (more than,
        say, 2) indicates errors in the input. To avoid overplottin, values
        between -0.25 and 0.25 are not plotted.} 
\end{figure}



%#####################

\subsection{Mapping features between GFF given scaffold}

\begin{figure}[!ht]
    \centering
<<fig.width=6, fig.height=4, message=FALSE, cache=TRUE>>=
require(reshape2)
require(ggplot2)
require(gridExtra)
require(dplyr)

m <- lapply(results, function(x) x$bittbl) %>%
  melt(id.vars='bit', value.name='proportion', variable.name='class') %>%
  subset(class %in% c('non_orp_prop', 'orp_prop')) %>%
  dplyr::rename(species=L1)
  ggplot(m) +
      geom_point(aes(x=bit, y=proportion, color=class)) +
      geom_line(aes(x=bit, y=proportion, group=class)) +
      xlab('Synteny flags') +
      ylab('Proportion') +
      theme(
          axis.text.x = element_text(angle=270, hjust=0, vjust=1),
          legend.position=c(1, 1),
          legend.justification=c(1, 1)
      ) +
      facet_wrap(~species)
@
  \caption{\textbf{Synteny flags}. \textbf{(0)} the search interval is reliable;
    \textbf{(1)} the start edge is unreliable; \textbf{(2)} the stop edge is
    unreliable; \textbf{(3)} edges are unreliable, but there is overlap;
    \textbf{(4)} syntenically unreliable}.
  \label{fig:synflags}
\end{figure}



<<results='asis'>>=
require(xtable)
xtable(m, caption=sprintf('Number of genes in each syntenic class.'))
@



\subsection{Find queries that overlap target CDS}

\begin{figure}[!ht]
    \centering
<<fig.width=6, fig.height=4, message=FALSE, cache=TRUE>>=
require(ggplot2)
require(scales)
lapply(results, function(x){
  featureCountTable(x$fo.cds) %>%
    {data.frame(
      N.cds=as.numeric(row.names(.)),
      count=.$Count)
    }
  }
) %>% melt(id.vars=c('N.cds', 'count')) %>% dplyr::rename(species=L1) %>%
  ggplot +
    geom_point(aes(x=N.cds, y=count)) +
    xlab('Number of overlapped CDSs') +
    ylab('Number of search intervals (log2)') +
    scale_y_continuous(
      trans='log2',
      breaks=trans_breaks('log2', function(x) round(2^x))
    ) +
    facet_wrap(~species)
@
  \caption{Number of CDS's overlapped by a single search interval}.
\end{figure}

<<results='asis'>>=
require(xtable)
lapply(results, function(x){
  featureCountTable(x$fo.mrna) %>%
    {data.frame(
      N.mrna=as.numeric(row.names(.)),
      count=.$Count)
    }
  }
) %>% melt(id.vars=c('N.mrna', 'count')) %>% dplyr::rename(species=L1) %>%
  xtable(caption='Number of target mRNAs overlapping one search interval')
@

% <<>>=
% n.orp.cds  <- fo.cds$orphan2target$query  %>% unique %>% length
% n.orp.mrna <- fo.mrna$orphan2target$query %>% unique %>% length
% n.orp <- query$orphans %>% unique %>% length
% @
% \begin{table}[!ht]
%     \centering
%     \label{tab:label}
%     \begin{tabular}{l | l | l}
%     feature & count & percent \\ 
%     \hline
%     CDS  & \Sexpr{n.orp.cds}  & \%\Sexpr{signif(100 * n.orp.cds  / n.orp, 2)} \\
%     mRNA & \Sexpr{n.orp.mrna} & \%\Sexpr{signif(100 * n.orp.mrna / n.orp, 2)} \\
%     \hline
%     \end{tabular}
%     \caption{Number of orphans with search intervals overlapping given features}
% \end{table}

\subsection{Find indel events}

% At least in the Arabidopsis thaliana versus Arabidopsis lyrata, all indel and
% resize events occur in no more than one search interval for a given query. In
% \Sexpr{length(q.res)} cases, the gene maps to only 1 search interval and is
% resized in it. Similarly for the \Sexpr{length(q.ind)} cases of indels. There
% are \Sexpr{nrow(d.irr)} cases where a gene maps to multiple search intervals,
% but still, only one of them is reduced or resized.

\subsection{Find queries overlapping N-strings}

\subsection{Find protein matches}

\subsection{Check orthology functionality against all non-orphans}

% <<>>=
% m <- data.frame(
%   group = c(rep('Ortholog', length(s.orth)),
%             rep('Overlapping', length(s.over)+1)),
%   N = c(names(s.orth), '0', names(s.over)) %>% as.integer,
%   count = c(s.orth, n.missing, s.over)
% )
% @
% <<results='asis'>>=
% require(xtable)
% m %>% xtable(caption=sprintf(
%  '\\textbf{Ortholog}: the number of query genes (count) where N target genes
%  both overlap a search interval AND have a high protein sequence similarity
%  score.  \\textbf{Overlapping}: the number of query genes (count) where N
%  target genes overlap a search interval.  %s\\%% of query genes have overlaps
%  and %s\\%% have identified orthologs.', perc.with.over, perc.with.orth))
% @


% \begin{figure}[!ht]
%     \centering
% <<fig.width=6, fig.height=6>>=
% require(ggplot2)
% require(scales)
% ggplot(aln$scores) +
%   geom_histogram(aes(x=score, y=..density..), bins=60) +
%   ggtitle('Protein alignment scores') +
%   xlab('Score') +
%   scale_x_continuous(
%     trans='log2',
%     breaks=trans_breaks('log2', function(x) round(2^x))
%   )
% @
%   \caption{
%     Scores of all local alignments against target genes in search intervals.
%     Note the bimodal distribution, which corresponds to the score of
%     non-homologous intervals versus homologous ones.
%   }
%   \label{fig:old-score}
% \end{figure}

\subsection{Detect overprinting}

\subsection{Detect protein hit to ORF}

\subsection{Find DNA hit}

% <<>>=
%   plot(
%     orp2dna$hits$qwidth,
%     orp2dna$hits$twidth,
%     xlab='Orphan gene length (bases)',
%     ylab='Search interval length (bases)'
%   )
% @
%
% \begin{figure}[!ht]
%   \centering
% <<>>=
% require(scales)
% require(ggplot2)
% d <- rbind(orp2dna$hits, orp2dna$ctrl)
% d$group <- c(rep('Real',     nrow(orp2dna$hits)),
%              rep('Permuted', nrow(orp2dna$ctrl))) %>% factor
% ggplot(d) +
%   geom_histogram(aes(x=score, y=..density..), bins=50) +
%   facet_wrap(~group) +
%   scale_x_continuous(
%     trans='log2',
%     breaks=trans_breaks('log2', function(x) round(2^x))
%   )
% @
%   \caption{\textbf{Permuted versus real alignment score.}}
%   \label{fig:nucscores}
% \end{figure}

\subsection{Leaf labels}


  % require(xtable)
  % label %>%
  %   factor %>%
  %   summary %>%
  %   as.data.frame %>%
  %   set_names('count') %>%
  %   xtable(caption='Labels for orphan genes')



\begin{description}

  \item[Candidate-gene] Query maps to an unannotated ORF with a high sequence
    similarity score. Currently I do not have a statistically sound method for
    selecting a threshold score and am just using a conservative 100 bit
    threshold.

  \item[Confirmed-genic] Query maps to one or more CDSs, and is significantly
    similar to at least one of the annotated target genes.

  \item[Indel] Query maps to bounded search interval that are less than 5\% the
    query gene length. AND the query maps to no other intervals.

  \item[Intergenic] Query maps to no mRNAs and ALL search intervals are
    bounded. The query overlaps no \textit{annotated} target gene.

  \item[Possible-genic] Query maps to one or more CDSs, but there is no
    predicted protein sequence similarity. 

  \item[Possible-hitchhiker] Query maps to one or more mRNAs but to no CDSs.

  \item[Possible-intergenic] Query maps to no mRNAs, but one or more search
    intervals is unbounded.

  \item[Unknown-gapped] The gene is of unknown origin and overlaps an
    unassembled regions (N-string).

  \item[Unknown-scrambled] No search intervals could be predicted for the query.

\end{description}

\subsection{Final Classifications}

Recursively merge all leaf labels to form final predictions of ancenstral
classes.
