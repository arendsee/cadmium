<<message=FALSE, warning=FALSE>>=

# TODO: check all inputs, and handle missing files appropriately
# TODO: the ranges for GFFs and SI are off by 1, e.g.
# $ target$si$query[1]
# $ query$gff[which(query$gff$seqid == target$si$query[1]$seqid)]
# TODO: in Arabidopsis lyrata, at least, there are out of bound intervals

require(GenomicRanges)
require(Biostrings)
require(ggplot2)
require(reshape2)
require(scales)
require(dplyr)
require(tidyr)
require(xtable)
require(robustreg)
require(fitdistrplus)
require(ape)
require(data.tree)
require(yaml)

source('~/src/git/fagin/src/report/R/util.R')
source('~/src/git/fagin/src/report/R/classification.R')
source('~/src/git/fagin/src/report/R/loadData.R')
source('~/src/git/fagin/src/report/R/indels.R')
source('~/src/git/fagin/src/report/R/syntenic_stats.R')
source('~/src/git/fagin/src/report/R/sequence_alignments.R')
source('~/src/git/fagin/src/report/R/feature_overlaps.R')

use_cache=TRUE
cache <- cache_factory(config)
config <- LoadConfig(configfile='~/src/git/fagin/fagin.cfg')
l_seqinfo <- LoadSeqinfoList(config)
query <- cache(LoadQuery, config, l_seqinfo)

get_results <- function(){
  results <- list()
  for(s in config$species){
    if(s %in% c(config$focal_species)){
      next
    }
    results[[s]] <- getTargetResults(
      species   = s,
      query     = query,
      config    = config,
      l_seqinfo = l_seqinfo,
      use_cache = use_cache
    )
  }
  results
}

get_model2locus_map <- function(query){
  model2locus <- query$gff %>%
    subset(type == 'mRNA') %>%
    mcols
  rownames(model2locus) <- model2locus$seqid
  model2locus <- model2locus['parent']
  model2locus
}

results <- cache(get_results)

model2locus <- get_model2locus_map(query)
labels <- determineLabels(query, results, config)
origin <- determineOrigins(labels, config)

@

\subsection{Gene stories}

<<>>=
load('../../cache/Arabidopsis_thaliana.vs.Arabidopsis_lyrata-LoadTarget.Rdat')
target <- out

q <- "AT4G18000.1"

names(query$gff) <- query$gff$seqid

query$gff[q]

qids <- findOverlaps(
  query$gff[q],
  target$syn$query,
  maxgap=1000L,
  ignore.strand=TRUE
) %$% subjectHits

range2df <- function(r, side, group){
  df <- ranges(r) %>% as.data.frame
  df$chr <- r %>% seqnames %>% as.character
  df$side <- side
  df$group <- group
  df$id <- 1:nrow(df)
  df
}

qints <- target$syn$query[qids]
tints <- target$syn$target[qints$over]
qsi   <- target$si$query[which(target$si$query$seqid == q)]
tsi   <- target$si$target[qsi$id]

d <- do.call(
    rbind,
    list(
        range2df(qints, 'query', 'syn'),
        range2df(tints, 'target', 'syn'),
        range2df(qsi, 'query', 'si'),
        range2df(tsi, 'target', 'si')
    )
)

d$y <- ifelse(d$side == 'target', 1, -1)
d$y[d$group == 'syn'] <- d$y[d$group == 'syn'] / 1.1
d$y <- d$y + runif(nrow(d), -0.01, 0.01)
d <- group_by(d, side, chr) %>%
    mutate(start=start - min(start) + 1, end=start + width - 1) %>%
    ungroup

# lines <- data.frame(
#     y=subset(d, side=='query', group=='syn') %$% y,
#     yend=subset(d, side=='query', group=='syn'),
# )

ggplot() +
    geom_segment(
        data=d,
        aes(
            x=start,
            xend=end,
            y=y,
            yend=y,
            color=group
        ),
        size=2,
        alpha=0.4
    ) #+
    # geom_segment(
    #     data=lines,
    #     aes(
    #         x=x,
    #         xend=xend,
    #         y=y,
    #         yend=yend
    #     )
    # )

@

\subsection{Data input}

<<echo=TRUE>>=
# number of loci in query
query$gff %>% mcols %>% subset(type == 'mRNA') %$% parent %>% unique %>% length

# number of orphans in query
model2locus[query$orphans, 'parent'] %>% unique %>% length
@


\begin{figure}[!ht]
    \centering
<<cache=TRUE, message=FALSE>>=
lapply(
  results,
  function(x){
    syn <- x$syn
    lograt <- log2(width(syn$query) / width(syn$target)[syn$query$over])
    lograt <- lograt[abs(lograt) > 0.25] 
    data.frame(
      lograt=lograt,
      index=1:length(lograt)
    )
  }
) %>% melt(id.vars=c('lograt', 'index')) %>% dplyr::rename(species=L1) %>%
ggplot +
  geom_point(aes(x=index, y=lograt), size=0.2) +
  xlab('Ordered position on query genome') +
  ylab('log2 of query to target length ratio') +
  facet_wrap(~species, scale='free_x')

@
    \caption{\textbf{Diagnostic plot of query to target lengths in synteny
        map}. The syntenic intervals on the query and target sides should
        be of similar length.  They will not be exactly the same size if gaps
        are allowed in the alignment, but wild deviation from 0 (more than,
        say, 2) indicates errors in the input. To avoid overplotting, values
        between -0.25 and 0.25 are not plotted.} 
\end{figure}



\subsection{Search interval overview}
%
Syntenic flags:
%
\begin{description}
  \item[0] the search interval is reliable
  \item[1] the start edge is unreliable
  \item[2] the stop edge is unreliable
  \item[3] both edges are unreliable, but there is an overlap
  \item[4] query is to the left of a contig, no overlap
  \item[5] query is to the right of a contig, no overlap
\end{description}

<<cache=TRUE>>=
m.syn <- lapply(results, function(x) {
  x <- x$synteny$flags
  x$seqid <- rownames(x)
  x %>%
    dplyr::group_by(seqid) %>%
    dplyr::summarize(
      A=as.logical(f0), 
      B=as.logical(f1 + f2 + f3),
      C=as.logical(f4 + f5)
    ) %>%
    with(
      data.frame(
        orphan = ifelse(seqid %in% query$orphans, 'orphan', 'non-orphan'),
        A =  A,
        B = !A &  B,
        C = !A & !B & C
      )
    ) %>%
    dplyr::group_by(orphan) %>%
    dplyr::summarize(
      A=sum(A),
      B=sum(B),
      C=sum(C)
    )
  }
) %>% melt %>% dplyr::rename(species=L1)
@
<<results='asis', cache=TRUE>>=
m.syn %>%
  group_by(orphan, species) %>%
  mutate(proportion=value/sum(value)) %>%
  dplyr::arrange(orphan, species, variable) %>%
  xtable(caption='A: numbers of genes with one or more flag==0 regions, B: !A
  and 1+ flag={1,2}, C: !A and !B and 1+ flag==3, D: else.')
@
<<fig.width=4, fig.height=4>>=
m.syn %>%
  dplyr::group_by(orphan, species) %>%
  dplyr::mutate(proportion=value/sum(value)) %>%
  dplyr::group_by(orphan, variable) %>%
  dplyr::summarize(proportion=mean(proportion)) %>%
  ggplot(aes(variable, proportion)) +
    geom_bar(aes(fill=orphan), stat='identity', position='dodge')
@

%
<<message=FALSE, cache=TRUE>>=
m <- lapply(results, function(x) x$synteny$bittbl) %>%
  lapply(dplyr::rename, orphan=orp_prop, non_orphan=non_orp_prop) %>%
  melt(id.vars='bit', value.name='proportion', variable.name='class') %>%
  subset(class %in% c('orphan', 'non_orphan')) %>%
  dplyr::rename(species=L1)
@
\begin{figure}[!ht]
    \centering
<<message=FALSE, cache=TRUE>>=
ggplot(m) +
    geom_line(aes(x=bit, y=proportion, group=class)) +
    geom_point(aes(x=bit, y=proportion, color=class)) +
    xlab('Synteny flags') +
    ylab('Proportion') +
    theme(
        axis.text.x = element_text(angle=270, hjust=0, vjust=1),
        legend.position=c(1, 1),
        legend.justification=c(1, 1)
    ) +
    facet_wrap(~species)
@
  \caption{\textbf{Synteny flags}. \textbf{(0)} the search interval is reliable;
    \textbf{(1)} the start edge is unreliable; \textbf{(2)} the stop edge is
    unreliable; \textbf{(3)} edges are unreliable, but there is overlap;
    \textbf{(4)} syntenically unreliable}.
  \label{fig:synflags}
\end{figure}
<<results='asis', cache=TRUE>>=
m %>%
  dplyr::mutate(proportion = signif(proportion * 100, 2)) %>%
  dcast(class + bit ~ species, mean, value.var='proportion') %>%
  xtable(caption=sprintf('Percent of genes in each syntenic class.'))
@
\begin{figure}[!ht]
  \centering
<<cache=TRUE, message=FALSE>>=
lapply(results, function(x) x$synteny$flags) %>%
  lapply(function(x) mutate(x, seqid=rownames(x))) %>%
  melt(id.vars='seqid') %>%
  dplyr::mutate(
    size = width(query$aa[seqid]),
    orph = ifelse(seqid %in% query$orphans, 'orphan', 'non-orphan')
  ) %>%
  dplyr::rename(flag=variable, species=L1) %>%
  subset(value > 0) %>%
  ggplot(aes(x=flag, y=size)) +
    geom_boxplot(width=0.5, notch=TRUE, outlier.size=0) +
    geom_violin(alpha=0.3) +
    facet_grid(species~orph) +
    scale_y_continuous(
      trans='log2',
      breaks=trans_breaks('log2', function(x) round(2^x))
    )
@
  \caption{\textbf{Length of genes versus syntenic flag}. Is their a
    relationship between flag class and gene length? It is reasonable that
    their would be. For example, a short interval would be less likely to be
    interupted. If the plots above suggest a meaningful difference, further
    quantitative studies may be warranted.}
  \label{fig:flag-vs-length}
\end{figure}

<<>>=
melt_seqaln <- function(field){
  m <- results %>%
    lapply(function(x) x[[field]][which(names(x[[field]]) %in% c('map', 'sam'))]) %>%
    melt(level=2, id.vars=c('score', 'pval', 'query')) %>%
    dplyr::select(-variable, -value) %>%
    dplyr::rename(group=L3, species=L2) %>%
    dplyr::group_by(query) %>%
    dplyr::filter(score == max(score)) %>%
    dplyr::filter(score > 0)
}

plot_seqaln <- function(d, cutoff){
  ggplot(d) +
    geom_violin(
      mapping=aes(x=species, y=-1*log2(pval)),
      data=m,
      alpha=0.3
    ) +
    geom_point(
      mapping=aes(x=species, y=-1*log2(pval)),
      data=subset(m, pval < cutoff) %>%
           dplyr::group_by(query, species) %>%
           dplyr::filter(score == max(score)) %>%
           as.data.frame,
      position=position_jitter(width=0.3),
      color='red'
    ) +
    geom_hline(yintercept=-1*log2(cutoff), color='red') +
    xlab('Raw alignment score (BLOSUM80)') +
    ylab('-log2(p)') +
    coord_flip() +
    facet_wrap(~group)
}
@


\subsection{Mapping to known target genes}
<<>>=
  m <- melt_seqaln('prot2prot')
  prot2prot.cutoff <- config$prot2prot_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, prot2prot.cutoff)
@


\subsection{Mapping to unknown ORFs on known mRNAs}
\begin{figure}[!ht]
  \centering
<<fig.width=6, fig.height=4, message=FALSE, cache=TRUE>>=
m <- lapply(results, function(x) x$features) %>%
    melt(id.vars=c('query', 'target'), level=2) %>%
    dplyr::rename(species=L2, type=L3) %>%
    dplyr::filter(type %in% c('CDS', 'mRNA', 'gene')) %>%
    dplyr::count(query, species, type) %>%
    dplyr::rename(n.feature=n) %>%
    dplyr::group_by(species, type, n.feature) %>%
    dplyr::tally()
m.zero <- m %>%
  group_by(species, type) %>%
  summarize(n=sum(n)) %>%
  mutate(
    n.feature = 0,
    n = length(query$aa) - n
  )
m2 <- rbind(m, m.zero)
ggplot(m2) +
  geom_point(aes(x=n.feature, y=n), size=0.2) +
  geom_line(aes(x=n.feature, y=n), alpha=0.05) +
  xlab('Number of overlapped features') +
  ylab('Number of search intervals') +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  ) +
  facet_grid(type~species)
@
  \caption{Number of target features overlapping a search interval}
\end{figure}
<<results='asis', cache=TRUE>>=
merge(
  results %>%
    lapply(function(x) x$features$CDS$query) %>%
    lapply(unique) %>%
    lapply(length) %>%
    melt %>%
    dplyr::rename(CDS=value, species=L1),
  results %>%
    lapply(function(x) x$features$mRNA$query) %>%
    lapply(unique) %>%
    lapply(function(x) sum(x %in% query$orphans)) %>%
    melt %>%
    dplyr::rename(mRNA=value, species=L1)
) %>% xtable(caption='Number of orphans with search intervals overlapping given features')
@

\begin{figure}[!ht]
<<>>=
  m <- melt_seqaln('prot2transorf')
  prot2transorf.cutoff <- config$prot2transorf_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, prot2transorf.cutoff)
@
  \caption{
    \textbf{Orphan genes hits against target ORFs}. All START/STOP bound open
    reading frames in the target genome were extracted. All orphan proteins
    were aligned against the ORFs that overlap one of their search intervals.
    Dots correspond to hits above \Sexpr{config$prot2allorf_minscore}.
  }
  \centering
\end{figure}


\subsection{Mapping to unknown ORFs outside known mRNAs}

\begin{figure}[!ht]
  \centering
<<>>=
  m <- melt_seqaln('prot2allorf')
  prot2allorf.cutoff <- config$prot2allorf_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, prot2allorf.cutoff)
@
  \caption{
    \textbf{Orphan genes hits against target ORFs}. All START/STOP bound open
    reading frames in the target genome were extracted. All orphan proteins
    were aligned against the ORFs that overlap one of their search intervals.
    Dots correspond to hits above \Sexpr{prot2allorf.cutoff}.
  }
\end{figure}


\subsection{Mapping to any DNA region in the search interval}
\begin{figure}[!ht]
  \centering
<<message=FALSE, warning=FALSE, cache=TRUE>>=
<<>>=
  m <- melt_seqaln('dna2dna')
  dna2dna.cutoff <- config$dna2dna_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, dna2dna.cutoff)
@
\caption{\
  Scores of orphan genes against their search intervals. In \textbf{ctrl}, the
  starting positions of the orphan genes were permuted while preserving their
  gene length. By chance, a few of these permuted indices may start on their
  original place, so there will be a few highscoring values. Dots correspond to
  orphans with scores above \Sexpr{dna2dna.cutoff}.
}
\end{figure}


\subsection{Find indel events}
<<results='asis', cache=TRUE>>=
results %>%
  lapply(function(x) x$ind.stats[1:2]) %>%
  melt %>%
  dplyr::rename(seqid=value, group=L2, species=L1) %>%
  dplyr::mutate(
    orphan = ifelse(seqid %in% query$orphans, 'orp', 'old'),
    group = sub('.queries', '', group)
  ) %>%
  dplyr::count(group, species, orphan) %>%
  dcast(species ~ group + orphan, mean, value.var='n') %>%
  dplyr::arrange(indeled_old, resized_old, indeled_orp, resized_orp) %>%
  dplyr::rename(
    ind_old=indeled_old, ind_orp=indeled_orp,
    res_old=resized_old, res_orp=resized_orp
  ) %>%
  xtable(
    display=c('s', 's', 'd', 'd', 'd', 'd'), 
    caption=
      'Summary of indel and resize events. A query is classified as indeled if at
      least one search interval is less than 5\\% of the length of the query. A
      query classified as resized if at least one search interval is between 5\\%
      and 100\\% the size of the query. Resize and indel events are only considered
      if the search interval is bounded (flag == 0), in which case the search
      interval length upper bounds the length of any contained homolog.'
  )
@


\subsection{Find queries overlapping N-strings}
<<results='asis', cache=TRUE>>=
results %>%
  lapply(function(x) unique(x$query2gap$query)) %>%
  melt %>%
  dplyr::mutate(
    orphan = ifelse(value %in% query$orphans, 'orphan', 'non-orphan')
  ) %>%
  dplyr::rename(species=L1) %>%
  dplyr::count(species, orphan) %>%
  dcast(species ~ orphan, mean, value.var='n') %>%
  xtable(
    display=c('s', 's', 'd', 'd'),
    caption=
    'The number of query genes for which at least one search interval overlaps
    at least one string of Ns (unknown bases) in the target genome. These genes
    could potentially be missed in sequence searches if the target homologs are
    inside these missing regions. NOTE: it cannot be assumed that the length of
    the N-string is equal to the length of the unknown region; the true unknown
    region length is often unknown, so a stretch of 100 Ns is often inserted to
    represent the gap of unknown length.'
  )
@

\subsection{Leaf labels}

<<results='asis', cache=TRUE>>=
labels$summary %>% xtable
@

\begin{figure}[!ht]
  \centering
<<>>=
labels$summary %>%
  dplyr::group_by(species) %>%
  mutate(proportion = count / sum(count)) %>%
  ggplot(aes(description, proportion)) +
  geom_bar(aes(fill=species), stat='identity', position='dodge') +
  coord_flip()
@
  \label{fig:}
\end{figure}

\begin{description}
  \item[CLASS 1: Genic]
    \begin{description}

      \item[known gene] Query has strong protein sequence similarity to a known
        target protein in the search interval.

      \item[unknown ORF off known mRNA] Query has strong protein sequence
        similarity to an unannotated open reading frame (ORF), bound by a STOP
        and START codon, that is in the search interval but that is NOT on a
        region known to be transcribed.

      \item[unknown ORF on known mRNA] Query has strong protein sequence
        similarity to an unannotated ORF on a spliced mRNA (but does not match
        a known genic ORF).

    \end{description}
  \item[CLASS 2: Non-genic]
    \begin{description}

      \item[CDS in SI] One of more known coding sequences (CDS) are in the
        search interval, but there is no predicted protein sequence similarity.

      \item[mRNA but not CDS in SI] One of more transcribed regions are in the
        search interval, but no CDS.

      \item[no gene in SI] No annotated coding genes are within the search interval.

      % \item[Intergenic] Query maps to no mRNAs and ALL search intervals are
      %   bounded. The query overlaps no \textit{annotated} target gene.
      %
      % \item[Possible-intergenic] Query maps to no mRNAs, but one or more search
      %   intervals is unbounded.

    \end{description}
  \item[CLASS 3: Unknown]
    \begin{description}

      \item[possible indel] Query maps to bounded search interval that is less
        than 5\% the query search interval length. AND the query maps to no other
        intervals.

      \item[possible N-string] The gene is of unknown origin and overlaps an
        unassembled regions (N-string).

      \item[possible resized] Query maps to bounded search interval that is
        5-100\% the query length. AND the query maps to no other intervals.
        These could correspond to indels, or expansions in the query search
        interval. I distinguish between resized and indeled because by the most
        common case where the search interval is smaller than the query is a
        full deletion, where the search interval length is 0. The 5\% cutoff is
        just to allow for inaccuracies in alignment. The true deletions have
        such a strong. My gerrymandering of the target intervals has obfuscated
        the query/target relation, I may need to rethink this.

      \item[syntenically scrambled] The query maps to target intervals that are
        unbounded and unanchored. Error in our search space estimates is a
        likely cause for not identifying the gene.

      \item[unknown] The synteny is reliable and there is no evidence of
        indels, but there is no sequence similarity of any sort to any of the
        search intervals. This could be caused be mutation completely past
        detectability, or by undetected deletions, or by transposition of the
        gene to a new context.

    \end{description}

\end{description}

\subsection{Final Classifications}

\begin{table}[!ht]
  \centering
  \begin{tabular}{| l | c c c |}
    \hline
    leaf states & gen & non & unk \\
    \hline
    gen gen & 1 & 0 & 0 \\
    gen non & 1 & 0 & 0 \\
    gen unk & 1 & 0 & 0 \\
    non non & 0 & 1 & 0 \\
    non unk & 0 & 0 & 1 \\
    unk unk & 0 & 0 & 1 \\
    \hline
  \end{tabular}

  \caption{Inference of parent based on child leaves. Assumes a bifurcating
    tree. \textbf{gen} is genic, \textbf{non} is non-genic, and \textbf{unk} is
    unknown. 1 and 0 are ancestor asignments, e.g. if the leafs are 'gen' and
    'gen', the ancestor is classified as 'gen' (as in column 1 row 1).}

  \label{tab:label}
\end{table}

<<>>=
print(origin$root, 'gen', 'non', 'unk')
@

<<results='asis'>>=
origin$backbone %>%
  dplyr::count(ps1, ps2, ps3) %>%
  xtable(caption='Counts of primaries labels in youngest to oldest strata')
@


\subsection{Gumbel fitting diagnostics}

<<>>=
require(fitdistrplus)
plot_fits <- function(group){
  for (species in names(results)){
    fit <- results[[species]][[group]]$dis$fit
    plot(fit, breaks=70)
    cat(sprintf('%s\n', species))
  }
}
@

\subsubsection{Query protein to target protein}

<<>>=
plot_fits('prot2prot')
@

\subsubsection{Query protein to spliced ORF}

<<>>=
plot_fits('prot2transorf')
@

\subsubsection{Query protein to any ORF}

<<>>=
plot_fits('prot2allorf')
@

\subsubsection{Query DNA to search interval DNA}

<<>>=
plot_fits('dna2dna')
@


% <<>>=
% a <- labels$labels %>% melt %>% dplyr::rename(species=L1, query=seqid)
% b <- results %>%
%   lapply(
%     function(x) {
%       data.frame(
%         bits=x$synteny$bits,
%         query=names(x$synteny$bits)
%       )
%     }
%   ) %>% melt %>%
%   dplyr::rename(species=L1)
% d <- merge(a, b, by=c('query', 'species')) %>%
%  merge(labels$summary[c('description', 'secondary')]) %>%
%  unique
% @
%
% <<bit-summaries>>=
% m <- split(d, d$bits) %>% lapply(function(x) x$description %>% factor %>% summary)
% @
%
% <<GGG-analysis>>=
% GGG <- origin$backbone %>%
%   subset(ps1 == 'gen' & ps2 == 'gen' & ps3=='gen') %>%
%   rownames
%
% GGG.labels <- labels$labels %>%
%   melt(id.vars=c('seqid', 'secondary'))  %>%
%   dplyr::rename(species=L1)
%
% GGG.gene.by.gene <- subset(d, query %in% GGG) %>%
%   dplyr::select(query, species, description) %>% 
%   {split(., f=factor(.$query))}
%
%   orphans <- query$orphans
%   p2p_cutoff <- config$prot2prot_pval     / length(orphans)
%   p2a_cutoff <- config$prot2allorf_pval   / length(orphans)
%   d2d_cutoff <- config$dna2dna_pval       / length(orphans)
%   p2t_cutoff <- config$prot2transorf_pval / length(orphans)
%
% # known aa seqs
% kaa <- list()
% # all ORF seqs
% oaa <- list()
% # all spliced ORF seqs
% taa <- list()
% for(s in config$species){
%   if(s == config$focal_species){
%     next
%   }
%   print(s)
%   kfile <- sprintf('%s/%s.faa', config$d_faa,       s)
%   kids <- results[[s]]$prot2prot$map     %>% subset(pval < 0.01) %$% target %>% unique
%   print(length(kids))
%   kaa[[s]] <- LoadFASTA(kfile, isAA=TRUE)[kids]
%   ofile <- sprintf('%s/%s.faa', config$d_orffaa,    s)
%   oids <- results[[s]]$prot2allorf$map   %>% subset(pval < 0.01) %$% target %>% unique
%   print(length(oids))
%   oaa[[s]] <- LoadFASTA(ofile, isAA=TRUE)[oids]
%   tfile <- sprintf('%s/%s.faa', config$d_trans_orf, s)
%   tids <- results[[s]]$prot2transorf$map %>% subset(pval < 0.01) %$% target %>% unique
%   print(length(tids))
%   taa[[s]] <- LoadFASTA(tfile, isAA=TRUE)[tids]
% }
%
% gg <- results %>%
%   lapply(function(x) x$prot2allorf$map %>% subset(pval < p2a_cutoff)) %>% 
%   melt %>%
%   dplyr::rename(species=L1) %>%
%   dplyr::select(query, target, species)
%
%   count(class) %>%
%   xtable(caption='Counts of primaries labels in youngest to oldest strata')
% @
