<<message=FALSE>>=
require(GenomicRanges)
require(Biostrings)
require(ggplot2)
require(reshape2)
require(scales)
require(dplyr)
require(xtable)
@

<<results, message=FALSE, warning=FALSE, cache=TRUE>>=
# TODO: check all inputs, and handle missing files appropriately

source('~/src/git/cadmium/src/report/R/classification.R')
source('~/src/git/cadmium/src/report/R/loadData.R')
source('~/src/git/cadmium/src/report/R/indels.R')
source('~/src/git/cadmium/src/report/R/syntenic_stats.R')
source('~/src/git/cadmium/src/report/R/sequence_alignments.R')
source('~/src/git/cadmium/src/report/R/feature_overlaps.R')

config <- LoadConfig(configfile='~/src/git/cadmium/cadmium.cfg')

l_seqinfo <- LoadSeqinfoList(config)

query.cache <- sprintf('%s/query.Rdat', config$d_cache)
if(file.exists(query.cache)){
  load(query.cache)
} else {
  query <- LoadQuery(config, l_seqinfo)
  save(query, file=query.cache)
}

results.cache <- sprintf('%s/results.Rdat', config$d_cache)
if(file.exists(results.cache)){
  load(results.cache)
} else {
  results <- list()
  for(s in config$species){
    if(s %in% c(config$focal_species)){
      next
    }
    results[[s]] <- getTargetResults(
      species   = s,
      query     = query,
      config    = config,
      l_seqinfo = l_seqinfo,
      use_cache = TRUE
    )
  }
  save(results, file=results.cache)
}

labels <- determineLabels(query, results)
@

\subsection{Data input}

\begin{figure}[!ht]
    \centering
<<cache=TRUE, message=FALSE>>=
lapply(
  results,
  function(x){
    syn <- x$syn
    lograt <- log2(width(syn$query) / width(syn$target)[syn$query$over])
    lograt <- lograt[abs(lograt) > 0.25] 
    data.frame(
      lograt=lograt,
      index=1:length(lograt)
    )
  }
) %>% melt(id.vars=c('lograt', 'index')) %>% dplyr::rename(species=L1) %>%
ggplot +
  geom_point(aes(x=index, y=lograt), size=0.2) +
  xlab('Ordered position on query genome') +
  ylab('log2 of query to target length ratio') +
  facet_wrap(~species, scale='free_x')
@
    \caption{\textbf{Diagnostic plot of query to target lengths in synteny
        map}. The syntenic intervals on the query and target sides should
        be of similar length.  They will not be exactly the same size if gaps
        are allowed in the alignment, but wild deviation from 0 (more than,
        say, 2) indicates errors in the input. To avoid overplotting, values
        between -0.25 and 0.25 are not plotted.} 
\end{figure}



\subsection{Search interval overview}

Syntenic flags:

\begin{description}
  \item[0] the search interval is reliable
  \item[1] the start edge is unreliable
  \item[2] the stop edge is unreliable
  \item[3] both edges are unreliable, but there is an overlap
  \item[4] neither edge of the search interval is reliable
\end{description}

<<message=FALSE, cache=TRUE>>=
m <- lapply(results, function(x) x$synteny$bittbl) %>%
  lapply(dplyr::rename, orphan=orp_prop, non_orphan=non_orp_prop) %>%
  melt(id.vars='bit', value.name='proportion', variable.name='class') %>%
  subset(class %in% c('orphan', 'non_orphan')) %>%
  dplyr::rename(species=L1)
@
\begin{figure}[!ht]
    \centering
<<message=FALSE, cache=TRUE>>=
ggplot(m) +
    geom_line(aes(x=bit, y=proportion, group=class)) +
    geom_point(aes(x=bit, y=proportion, color=class)) +
    xlab('Synteny flags') +
    ylab('Proportion') +
    theme(
        axis.text.x = element_text(angle=270, hjust=0, vjust=1),
        legend.position=c(1, 1),
        legend.justification=c(1, 1)
    ) +
    facet_wrap(~species)
@
  \caption{\textbf{Synteny flags}. \textbf{(0)} the search interval is reliable;
    \textbf{(1)} the start edge is unreliable; \textbf{(2)} the stop edge is
    unreliable; \textbf{(3)} edges are unreliable, but there is overlap;
    \textbf{(4)} syntenically unreliable}.
  \label{fig:synflags}
\end{figure}
<<results='asis', cache=TRUE>>=
m %>%
  dplyr::mutate(proportion = signif(proportion * 100, 2)) %>%
  dcast(class + bit ~ species, mean, value.var='proportion') %>%
  xtable(caption=sprintf('Percent of genes in each syntenic class.'))
@

\begin{figure}[!ht]
  \centering
<<cache=TRUE, message=FALSE>>=
lapply(results, function(x) x$synteny$flags) %>%
  lapply(function(x) mutate(x, seqid=rownames(x))) %>%
  melt(id.vars='seqid') %>%
  dplyr::mutate(
    size = width(query$aa[seqid]),
    orph = ifelse(seqid %in% query$orphans, 'orphan', 'non-orphan')
  ) %>%
  dplyr::rename(flag=variable, species=L1) %>%
  subset(value > 0) %>%
  ggplot(aes(x=flag, y=size)) +
    geom_boxplot(width=0.5, notch=TRUE, outlier.size=0) +
    geom_violin(alpha=0.3) +
    facet_grid(species~orph) +
    scale_y_continuous(
      trans='log2',
      breaks=trans_breaks('log2', function(x) round(2^x))
    )
@
  \caption{\textbf{Length of genes versus syntenic flag}. Is their a
    relationship between flag class and gene length? It is reasonable that
    their would be. For example, a short interval would be less likely to be
    interupted. If the plots above suggest a meaningful difference, further
    quantitative studies may be warranted.}
  \label{fig:flag-vs-length}
\end{figure}



\subsection{Mapping features between GFF given scaffold}


% ----------------------
% summarize CDS overlaps
% ----------------------

% \begin{figure}[!ht]
%     \centering
% <<fig.width=6, fig.height=4, message=FALSE, cache=TRUE>>=
% # featureCountTable <- function(feat){
% #   lapply(feat$overlaps, length) %>% 
% #       unlist %>% factor %>% summary(maxsum=Inf) %>%
% #       data.frame(.) %>%
% #       set_names('Count')
% # }
%
% # TODO: rewrite this with 
% lapply(results, function(x) x$features$CDS) %>%
%   melt %>%
%   dplyr::rename(species=L1) %>%
%   # TODO: convert target to CDS count
%   count(query, species) %>%
%   dplyr::rename(N.cds=n) %>%
%   count(species, N.cds)
%
%
%   featureCountTable(x$features$CDS) %>%
%     {data.frame(
%       N.cds=as.numeric(row.names(.)),
%       count=.$Count)
%     }
%   %>% melt(id.vars=c('N.cds', 'count')) %>% dplyr::rename(species=L1) %>%
%   ggplot +
%     geom_point(aes(x=N.cds, y=count), size=0.2) +
%     xlab('Number of overlapped CDSs') +
%     ylab('Number of search intervals') +
%     scale_y_continuous(
%       trans='log2',
%       breaks=trans_breaks('log2', function(x) round(2^x))
%     ) +
%     facet_wrap(~species)
% @
%   \caption{Number of CDS's overlapped by a single search interval}.
% \end{figure}


% -----------------------
% summarize mRNA overlaps
% -----------------------
\begin{figure}[!ht]
  \centering
<<fig.width=6, fig.height=4, message=FALSE, cache=TRUE>>=
require(tidyr)

m <- lapply(results, function(x) x$features) %>%
    melt(id.vars=c('query', 'target'), level=2) %>%
    dplyr::rename(species=L2, type=L3) %>%
    filter(type %in% c('CDS', 'mRNA', 'gene')) %>%
    count(query, species, type) %>%
    dplyr::rename(n.feature=n) %>%
    count(species, type, n.feature)
m.zero <- m %>%
  group_by(species, type) %>%
  summarize(n=sum(n)) %>%
  mutate(
    n.feature = 0,
    n = length(query$aa) - n
  )
m2 <- rbind(m, m.zero)

ggplot(m2) +
  geom_point(aes(x=n.feature, y=n), size=0.2) +
  geom_line(aes(x=n.feature, y=n), alpha=0.05) +
  xlab('Number of overlapped mRNAs') +
  ylab('Number of search intervals') +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  ) +
  facet_grid(type~species)

@
  \caption{Number of target mRNAs overlapping one search interval}
\end{figure}


% --------------------------------------
% summarize mRNA and CDS in common table
% --------------------------------------
<<results='asis', cache=TRUE>>=
merge(
  results %>%
    lapply(function(x) x$features$CDS$query) %>%
    lapply(unique) %>%
    lapply(length) %>%
    melt %>%
    dplyr::rename(CDS=value, species=L1),
  results %>%
    lapply(function(x) x$features$mRNA$query) %>%
    lapply(unique) %>%
    lapply(function(x) sum(x %in% query$orphans)) %>%
    melt %>%
    dplyr::rename(mRNA=value, species=L1)
) %>% xtable(caption='Number of orphans with search intervals overlapping given features')
@

\subsection{Find indel events}

<<results='asis', cache=TRUE>>=
results %>%
  lapply(function(x) x$ind.stats[1:2]) %>%
  melt %>%
  dplyr::rename(seqid=value, group=L2, species=L1) %>%
  dplyr::mutate(
    orphan = ifelse(seqid %in% query$orphans, 'orp', 'old'),
    group = sub('.queries', '', group)
  ) %>%
  dplyr::count(group, species, orphan) %>%
  dcast(species ~ group + orphan, mean, value.var='n') %>%
  dplyr::arrange(indeled_old, resized_old, indeled_orp, resized_orp) %>%
  dplyr::rename(
    ind_old=indeled_old, ind_orp=indeled_orp,
    res_old=resized_old, res_orp=resized_orp
  ) %>%
  xtable(
    display=c('s', 's', 'd', 'd', 'd', 'd'), 
    caption=
      'Summary of indel and resize events. A query is classified as indeled if at
      least one search interval is less than 5\\% of the length of the query. A
      query classified as resized if at least one search interval is between 5\\%
      and 100\\% the size of the query. Resize and indel events are only considered
      if the search interval is bounded (flag == 0), in which case the search
      interval length upper bounds the length of any contained homolog.'
  )
@
% At least in the Arabidopsis thaliana versus Arabidopsis lyrata, all indel and
% resize events occur in no more than one search interval for a given query. In
% \Sexpr{length(q.res)} cases, the gene maps to only 1 search interval and is
% resized in it. Similarly for the \Sexpr{length(q.ind)} cases of indels. There
% are \Sexpr{nrow(d.irr)} cases where a gene maps to multiple search intervals,
% but still, only one of them is reduced or resized.

\subsection{Find queries overlapping N-strings}

<<results='asis', cache=TRUE>>=
results %>%
  lapply(function(x) unique(x$query2gap$query)) %>%
  melt %>%
  dplyr::mutate(
    orphan = ifelse(value %in% query$orphans, 'orphan', 'non-orphan')
  ) %>%
  dplyr::rename(species=L1) %>%
  dplyr::count(species, orphan) %>%
  dcast(species ~ orphan, mean, value.var='n') %>%
  xtable(
    display=c('s', 's', 'd', 'd'),
    caption=
    'The number of query genes for which at least one search interval overlaps
    at least one string of Ns (unknown bases) in the target genome. These genes
    could potentially be missed in sequence searches if the target homologs are
    inside these missing regions. NOTE: it cannot be assumed that the length of
    the N-string is equal to the length of the unknown region; the true unknown
    region length is often unknown, so a stretch of 100 Ns is often inserted to
    represent the gap of unknown length.'
  )
@

\subsection{Find protein matches}

\begin{figure}[!ht]
  \centering
<<message=FALSE, cache=TRUE>>=

m <- results %>% 
  lapply(function(x) x$prot2prot[c('query', 'score')]) %>%
  melt(id.vars=c('query', 'score')) %>%
  dplyr::rename(species=L1) %>%
  dplyr::mutate(orphan = (query %in% query$orphans))

ggplot() +
  geom_violin(
    mapping=aes(x=species, y=score),
    data=m,
    alpha=0.3
  ) +
  geom_point(
    mapping=aes(x=species, y=score, color=orphan),
    data=subset(m, score > 64 & orphan) %>%
         dplyr::group_by(query, species) %>%
         dplyr::summarize(score=max(score)) %>%
         as.data.frame,
    position=position_jitter(width=0.3),
    color='red'
  ) +
  xlab('Raw alignment score (BLOSUM80)') +
  theme(
    axis.text.x = element_text(angle=325, hjust=0, vjust=1)
  ) +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  )

@
  \caption{\
    Non-orphan genes are expected to have at a highscoring homolog, so there
    should be many high scoring hits. There should also be many low scoring
    ones, from the searches against genes that overlap the search interval but
    are not homologous. \textbf{In red:} the orphan genes with scores above 64
    against genic targets within their search intervals.
  }
\end{figure}

<<results='asis', cache=TRUE>>=
m %>%
  subset(score > 64) %>%
  dplyr::mutate(orphan = ifelse(orphan, 'orphan', 'non-orphan') %>% factor) %>%
  count(species, orphan) %>%
  xtable(
    caption='The number of query orphans and non-orphans with significant
    ($score > 64$) similarity to annotated genes in each target genome.'
  )
@
% <<>>=
% m <- data.frame(
%   group = c(rep('Ortholog', length(s.orth)),
%             rep('Overlapping', length(s.over)+1)),
%   N = c(names(s.orth), '0', names(s.over)) %>% as.integer,
%   count = c(s.orth, n.missing, s.over)
% )
% @
% <<results='asis'>>=
% require(xtable)
% m %>% xtable(caption=sprintf(
%  '\\textbf{Ortholog}: the number of query genes (count) where N target genes
%  both overlap a search interval AND have a high protein sequence similarity
%  score.  \\textbf{Overlapping}: the number of query genes (count) where N
%  target genes overlap a search interval.  %s\\%% of query genes have overlaps
%  and %s\\%% have identified orthologs.', perc.with.over, perc.with.orth))
% @

\subsection{Detect protein hit to ORF}

\begin{figure}[!ht]
  \centering
<<message=FALSE, cache=TRUE>>=
m <- results %>% 
  lapply(function(x) x$orfmap[c('query', 'score')]) %>%
  melt(id.vars=c('query', 'score')) %>%
  dplyr::rename(species=L1)
ggplot(m) +
  geom_violin(
    mapping=aes(x=species, y=score),
    data=m,
    alpha=0.3
  ) +
  geom_point(
    mapping=aes(x=species, y=score),
    data=subset(m, score > 64),
    position=position_jitter(width=0.8),
    alpha=0.3
  ) +
  theme(
    axis.text.x = element_text(angle=325, hjust=0, vjust=1)
  ) +
  xlab('Raw alignment score (BLOSUM80)') +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  )
@
  \caption{
    \textbf{Orphan genes hits against target ORFs}. All START/STOP bound open
    reading frames in the target genome were extracted. All orphan proteins
    were aligned against the ORFs that overlap one of their search intervals.
    Dots correspond to hits above 64.
  }
\end{figure}


\subsection{Find DNA hit}

\begin{figure}[!ht]
  \centering
<<message=FALSE, warning=FALSE, cache=TRUE>>=
m <- results %>%
  lapply(function(x) x$orp2dna) %>%
  melt(id.vars=c('score', 'qwidth', 'twidth', 'seqid')) %>%
  dplyr::rename(group=L2, species=L1)

ggplot(m) +
  geom_violin(
    mapping=aes(x=species, y=score),
    data=m,
    alpha=0.3
  ) +
  geom_point(
    mapping=aes(x=species, y=score),
    data=subset(m, score > 64),
    position=position_jitter(width=1),
    alpha=0.2
  ) +
  xlab('Raw alignment score (BLOSUM80)') +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  ) +
  coord_flip() +
  facet_grid(group~.)
@
\caption{\
  Scores of orphan genes against their search intervals. In \textbf{ctrl}, the
  starting positions of the orphan genes were permuted while preserving their
  gene length. By chance, a few of these permuted indices may start on their
  original place, so there will be a few highscoring values.
}
\end{figure}

\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
m %>%
  group_by(seqid, group, species) %>%
  summarize(
    score=max(score),
    qwidth=max(qwidth),
    twidth=max(twidth)
  ) %>%
  dplyr::mutate(signif=score > 64) %>%
  ggplot +
      geom_point(
        aes(
          x=qwidth,
          y=twidth,
          color=signif,
          size=score
        ),
        alpha=0.5
      ) +
      xlab('Query gene width') +
      ylab('Target search interval width') +
      facet_wrap(~species) +
      scale_x_continuous(
        trans='log2',
        breaks=trans_breaks('log2', function(x) round(2^x))
      ) +
      scale_y_continuous(
        trans='log2',
        breaks=trans_breaks('log2', function(x) round(2^x))
      )
@
\caption{\
  \textbf{Query gene length versus target search interval length}. The size of
  the points is proportional to score of the gene's best hit. A hit is
  considered significant if it is above a certain threshold (64 bits for now).
}
\end{figure}

\subsection{Leaf labels}

<<results='asis', cache=TRUE>>=
labels$summary %>%
  arrange(description, species, count) %>%
  select(description, species, count) %>%
  tidyr::complete(description, species, fill=list(count=0)) %>%
  as.data.frame %>%
  dplyr::mutate(count = as.integer(count)) %>%
  xtable
@

\begin{description}

  \item[Candidate-gene] Query maps to an unannotated ORF with a high sequence
    similarity score. Currently I do not have a statistically sound method for
    selecting a threshold score and am just using a conservative 100 bit
    threshold.

  \item[Confirmed-genic] Query maps to one or more CDSs, and is significantly
    similar to at least one of the annotated target genes.

  \item[Indel] Query maps to bounded search interval that are less than 5\% the
    query gene length. AND the query maps to no other intervals.

  \item[Intergenic] Query maps to no mRNAs and ALL search intervals are
    bounded. The query overlaps no \textit{annotated} target gene.

  \item[Possible-genic] Query maps to one or more CDSs, but there is no
    predicted protein sequence similarity. 

  \item[Possible-hitchhiker] Query maps to one or more mRNAs but to no CDSs.

  \item[Possible-intergenic] Query maps to no mRNAs, but one or more search
    intervals is unbounded.

  \item[Unknown-gapped] The gene is of unknown origin and overlaps an
    unassembled regions (N-string).

  \item[Unknown-scrambled] No search intervals could be predicted for the query.

\end{description}

\subsection{Final Classifications}

Recursively merge all leaf labels to form final predictions of ancenstral
classes.
