<<cache=FALSE, message=FALSE, warning=FALSE>>=
source('~/src/git/cadmium/src/report/R/classification.R')
source('~/src/git/cadmium/src/report/R/loadData.R')
@

<<cache=TRUE, message=FALSE, warning=FALSE>>=
query <- LoadQuery()
target <- LoadTarget()
@

<<sflags, cache=TRUE>>=
sflags <- summarize.flags(target$si)
@

<<cache=TRUE>>=
genelist <- target$si$query$seqid %>% unique

tgenes <- target$gff$seqid %>% unique

stopifnot(genelist %in% names(query$aa))
stopifnot(tgenes %in% names(target$aa))

# The pipeline builds the protein sequences from the GFF and genome files, so
# the sequence ids in the faa and search interval files should be the same.  It
# is perfectly plausible that some proteins are known from mRNAs but are not
# placed in the genome (due to missing sequence, ambiguities or curator error).
# It is also reasonable that the user might try to bypass my helpful protein
# file preparations. They might try to slip in some of their own pet proteins.
# I could accomadate them, but I choose not to. Indeed, I would die first:
stopifnot(genelist %in% names(query$aa))
query$aa <- query$aa[genelist]

origins <- data.frame(
    seqid=genelist,
    class=rep(NA, length(genelist))
)

origins <- merge(origins, sflags)

origins$orphan <- origins$seqid %in% query$orphans

origins$bit <- origins[,3:7] %>%
    apply(1, function(x) paste0(as.numeric(x > 0), collapse='')) %>%
    factor

bittbl <- data.frame(
    non_orphan = summary(subset(origins,  orphan)$bit),
    orphan     = summary(subset(origins, !orphan)$bit)
)

bittbl.norm <- bittbl %>%
    apply(1, function(x) x / colSums(bittbl)) %>% t %>% data.frame

bittbl$bit <- row.names(bittbl)
bittbl.norm$bit <- bittbl$bit
@

<<results='asis'>>=
    require(xtable)
    m <- merge(bittbl, bittbl.norm, by='bit')
    names(m) <- c('bit', 'non_orp_count', 'orp_count', 'non_orp_prop', 'orp_prop')
    xtable(m, caption='Number of genes in each syntenic class.')
@

\begin{figure}[!ht]
    \centering
<<fig.width=6, fig.height=4, message=FALSE>>=
require(reshape2)
require(ggplot2)
m <- melt(
    bittbl.norm,
    id.vars='bit',
    value.name='proportion',
    variable.name='class'
)
ggplot(m) +
    geom_point(aes(x=bit, y=proportion, color=class)) +
    geom_line(aes(x=bit, y=proportion, group=class)) +
    ggtitle('title') +
    xlab('Synteny flags') +
    ylab('Proportion') +
    theme(
        axis.text.x = element_text(angle=270, hjust=0, vjust=1)
    )
@

\caption{\textbf{Synteny flags}. \textbf{(0)} the search interval is reliable;
    \textbf{(1)} the start edge is unreliable; \textbf{(2)} the stop edge is
    unreliable; \textbf{(3)} edges are unreliable, but there is overlap;
        \textbf{(4)} syntenically unreliable}.

    \label{fig:synflags}
\end{figure}


% <<>>=
% require(genomeIntervals)
% 
% # Load GFFs of both target and query as genomeInterval files
% # - modifying LoadGFF()
% 
% # Load search intervals as pair of genomeIntervals but keyed by search interval
% # id. An internal one, i.e. 1-n.
% 
% # Foreach search interval, find the genes in the target that it overlaps
% # Align the query gene to the target gene AA seq
% # - deal with score somehow
% # - if has hit, return class
% 
% # Foreach search interval, 
% @
