\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{wrapfig}
\usepackage{color}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=blue,
    linkcolor=blue,
    urlcolor=blue
}

\DeclareUnicodeCharacter{00A6}{|}
\DeclareUnicodeCharacter{00B0}{*}

% Prevent floats from crossing section or subsection boundaries
\usepackage[section]{placeins}
% Credit for this voodoo goes to Heiko Oberdiek
\makeatletter
\AtBeginDocument{%
  \expandafter\renewcommand\expandafter\subsection\expandafter{%
    \expandafter\@fb@secFB\subsection
  }%
}
\makeatother

<<knit-options, echo=FALSE>>=
  # Don't echo all the R code
  opts_chunk$set(echo=FALSE)
@

\title{Report}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}

The Fagin pipeline receives input from the Synder, which uses a synteny
framework to map genes in one genome to search intervals in another.

<<load_libraries, message=FALSE>>=

require(ape)
require(Biostrings)
require(data.tree)
require(dplyr)
require(fitdistrplus)
require(GenomicRanges)
require(ggplot2)
require(gridExtra)
require(magrittr)
require(reshape2)
require(robustreg)
require(scales)
require(tidyr)
require(xtable)
require(yaml)

source('R/util.R')
source('R/classification.R')
source('R/loadData.R')
source('R/indels.R')
source('R/syntenic_stats.R')
source('R/sequence_alignments.R')
source('R/feature_overlaps.R')
source('R/plot.R')
source('R/versions.R')

# log_file <- file("log.Rout", open="wt")
# sink(log_file, type=c("output", "message"))

use_cache <- TRUE
config    <- LoadConfig(configfile='config')
cache     <- cache_factory(config)
l_seqinfo <- LoadSeqinfoList(config)
query     <- cache(LoadQuery, config, l_seqinfo)

@

\section{Input Data}

\subsection{Species phylogeny}

<<view-tree>>=
tree <- read.tree(config$f_tree)
plot(tree)
@

\subsection{Genomic statistics}

\begin{figure}
    \center
<<plot-scaffold-lengths, message=FALSE, cache=FALSE>>=
scaflen <- read.table(config$f_scaflen, header=TRUE)
scaflen <- group_by(scaflen, species) %>%
    arrange(-length) %>%
    mutate(idx=1:length(scaffold)) %>%
    droplevels
ggplot(scaflen) +
    geom_point(aes(x=idx, y=length), size=0.2) +
    scale_y_continuous(
        trans='log10',
        breaks=trans_breaks('log10', function(x) round(10^x))
    ) +
    facet_wrap(~species, scales='free_x')
@
    \caption{\textbf{Scaffold lengths}. Sorted by length on x-axis.}
\end{figure}

\begin{figure}
    \center
<<plot-scaffold-lengths-2, cache=FALSE, fig.width=7, fig.height=6>>=
# This is the longest scaffold that will be represented
plotting_threshold = 1e5
scaflen$chrid <- factor(scaflen$idx)
scaflen_chr <- subset(scaflen, length > plotting_threshold) %>% droplevels

ggplot(scaflen_chr) +
    geom_path(aes(x=chrid, y=length, group=species)) +
    geom_point(aes(x=chrid, y=length, color=species), size=4) +
    xlab('Scaffold number (by size)') +
    ylab('Scaffold length (in DNA bases)') +
    theme(
        legend.position=c(1, 1),
        legend.justification=c(1, 1)
    )
@
    \caption{Lengths of scaffolds greater than \Sexpr{plotting_threshold} bases
    in length. This threshold is fairly arbitrary. The goal of this plot to
    reduce overplotting by zooming in on the larger side of spectrum.}
\end{figure}

\begin{figure}[!ht]
    \centering
<<plot-nstring, cache=FALSE>>=
nstring <- read.table(config$f_nstrings, header=TRUE)
nstring$length <- with(nstring, stop - start + 1)

if(nrow(nstring) > 0){
  dplyr::rename(scaflen_chr, scaffold_length = length) %>%
    merge(nstring, by=c('species', 'scaffold')) %>%
    ggplot +
      geom_segment(
          aes(
              y=idx,
              yend=idx,
              x=start,
              xend=stop),
          size=5) +
      geom_segment(
          aes(
              y=idx,
              yend=idx,
              x=1,
              xend=scaffold_length),
          size=0.2) +
      geom_text(
          aes(
              y=idx + 0.2,
              x=scaffold_length,
              label=scaffold),
          hjust='left',
          family='sans',
          fontface='plain',
          size=2) +
      facet_wrap(~species, scales='free_y')
} else {
  ggplot(nstring) # an empty box
}
@
    \caption{\textbf{Strings of unknowns}. Most assemblies have certain regions
    who lengths may be known but no sequence is available, these regions may be
    replaced with strings of consecutive N's. The vertical bars in this plot
    correspond to these regions, with width proportional to the number of N's.
    Only scaffolds with lengths greater than \Sexpr{plotting_threshold} Mb are
    shown. \textbf{NOTE:} if this figure is empty, then there are no strings of
    N's in any of your assemblies (nothing to worry about).}
\end{figure}

\begin{figure}[!ht]
  \centering
<<plot-gc, cache=FALSE>>=
d <- read.table(config$f_kbcomp, header=TRUE) %>%
  (
    function(d) {
      if("N" %in% names(d)){
        d <- subset(d, N == 0)
      }
      d
    }
  ) %>%
  dplyr::mutate(GC = (C + G) / (A + C + G + T))

# Number of species in the analysis (focal species included)
nspecies <- nlevels(factor(d$species))

# Number of random intervals taken from each species
# Should be an integer (e.g. 10000)
sample_size <- nrow(d) / nspecies

# Length of the intervals drawn from the genomes
sample_interval_length <- d[-c(1,2,3,4)] %>% rowSums %>% mean

# NOTE: Formally, I ought to deal with ambiguous bases, e.g. Y for pyrimidine.
# Not doing so is basically OK, since the visual difference will be negligible.
# These ambiguous bases are seldom used.

ggplot(d) +
  geom_boxplot(aes(x=species, y=GC), width=0.2) +
  geom_violin(aes(x=species, y=GC), alpha=0.3) +
  ylab('G+C Proportion') +
  theme(axis.text.x = element_text(angle=270, hjust=0, vjust=1))

@
    \caption{\textbf{GC content comparison}. This is a diagnostic plot for
    comparing the median and variability of GC content between species.
    \Sexpr{round(sample_size)} intervals of length
    \Sexpr{round(sample_interval_length)} were drawn randomly from each
    species. The bases in each interval were counted and GC content was
    calculated as $g = (n_g + n_c) / (n_g + n_c + n_a + n_t)$ (intervals with
    characters other than these were ignored). The violin plots show the
    distribution of $g$ across samples. The boxplot inside the violin plot
    shows the median and 25th and 75th quantiles. \textit{Interpretation:} the
    plot ought to look pretty similar across the species. Weird events like
    massive transposon proliferation in one species might lead to shifts.}
\end{figure}

\section{Synteny}

<<main-chunk, message=FALSE, warning=FALSE>>=

get_results <- function(){
  results <- list()
  for(s in config$species){
    if(s %in% c(config$focal_species)){
      next
    }
    results[[s]] <- getTargetResults(
      species   = s,
      query     = query,
      config    = config,
      l_seqinfo = l_seqinfo,
      use_cache = use_cache
    )
  }
  results
}

get_model2locus_map <- function(query){
  model2locus <- query$gff %>%
    subset(type == 'mRNA') %>%
    mcols
  rownames(model2locus) <- model2locus$seqid
  model2locus <- model2locus['parent']
  model2locus
}

results <- cache(get_results)

model2locus <- get_model2locus_map(query)
labels <- determineLabels(query, results, config)
origin <- determineOrigins(labels, config)


# # ===================================================================
# merge_labels <- function(x, y){
#   x$primary = NULL
#   y$primary = NULL
#   merge(x, y, by="seqid")
# }
# 
# d <- base::Reduce(merge_labels, labels$labels)
# names(d) <- c("seqid", names(labels$labels))
# 
# 
# label_summary <- function(x){
#   fields=c("O1", "O2", "O3", "N1", "N2", "N3", "U1", "U2", "U3", "U4", "U5", "U6", "U7")
#   summary(factor(x, levels=fields))
# }
# 
# dd <- d
# dd$seqid <- NULL
# do.call(cbind, lapply(dd, label_summary)) %>% t
# 
# a <- summary(factor(d$Capsella_rubella, levels=fields))
# b <- summary(factor(d$Brassica_rapa, levels=fields))
# cbind(a, b)
# # -------------------------------------------------------------------

@

<<query-loci-counts>>=
# number of loci in query
nloci <- query$gff %>%
  mcols %>%
  subset(type == 'mRNA') %$% parent %>%
  unique %>% length

# number of orphans in query
norphan_loci <- model2locus[query$orphans, 'parent'] %>%
  unique %>% length
@

\begin{figure}[!ht]
    \centering

<<synteny-diagnostic-scatter, cache=FALSE, message=FALSE>>=
d <- lapply(
  results,
  function(x){
    syn <- x$syn
    lograt <- log2(width(syn$query) / width(syn$target)[syn$query$over])
    lograt <- lograt[abs(lograt) > 0.25] 
  }
)

if(all(lapply(d, length) > 0)){
  lapply(
    d,
    data.frame(
      lograt=lograt,
      index=1:length(lograt)
    )
  ) %>% melt(id.vars=c('lograt', 'index')) %>% dplyr::rename(species=L1) %>%
  ggplot +
    geom_point(aes(x=index, y=lograt), size=0.2) +
    xlab('Ordered position on query genome') +
    ylab('log2 of query to target length ratio') +
    facet_wrap(~species, scale='free_x')
} else {
  ggplot(iris) # a hack to get a blank plot
}
@
  \caption{\textbf{Diagnostic plot of query to target lengths in synteny map}.
  The syntenic intervals on the query and target sides should be of similar
  length.  Here we plot ${\log}_2 \left(\frac{L_q}{L_t}\right)$.
  This will be 0 when the intervals are of equal length. It will be 1 when the
  query is twice the length of the target. The query and target intervals have
  different lengths if gaps are allowed in the alignments, but wild deviation
  from 0 suggests something is wrong To avoid overplotting, values between
  -0.25 and 0.25 are not plotted. \textbf{NOTE:} If the plot above is blank, it
  means the absolute log ratio was less then 0.25 for all syntenic pairs. This
  is fine, and for some synteny map programs, will always happen.}
\end{figure}


\subsection{Search interval overview}

% % TODO: Redo this, flag analysis should be handled by the synder package
% Syntenic flags:
%
% \begin{description}
%   \item[0] the search interval is reliable
%   \item[1] the start edge is unreliable
%   \item[2] the stop edge is unreliable
%   \item[3] both edges are unreliable, but there is an overlap
%   \item[4] query is to the left of a contig, no overlap
%   \item[5] query is to the right of a contig, no overlap
% \end{description}
%
% \begin{figure}[!ht]
%   \centering
% <<plot-flags>>=
% lapply(results, function(x) x$flagsum) %>%
%   melt %>%
%   set_names(c("group", "orphan", "proportion", "species")) %>%
%   ggplot(aes(species, proportion)) +
%     geom_bar(aes(fill=orphan), stat='identity', position='dodge') +
%     theme(axis.text.x = element_text(angle=270, hjust=0, vjust=1)) +
%     facet_wrap(~group)
% @
%   \caption{\textbf{STUB: plot-flags}}
% \end{figure}

<<>>=
melt_seqaln <- function(field){
  m <- results %>%
    lapply(function(x) x[[field]][which(names(x[[field]]) %in% c('map', 'sam'))]) %>%
    melt(level=2, id.vars=c('score', 'pval', 'query')) %>%
    dplyr::select(-variable, -value) %>%
    dplyr::rename(group=L3, species=L2) %>%
    dplyr::group_by(query) %>%
    dplyr::filter(score == max(score)) %>%
    dplyr::filter(score > 0)
}
# This is a utility plot function
plot_seqaln <- function(d, cutoff){
  ggplot(d) +
    geom_violin(
      mapping=aes(x=species, y=-1*log10(pval)),
      data=m,
      alpha=0.3
    ) +
    geom_point(
      mapping=aes(x=species, y=-1*log10(pval)),
      data=subset(m, pval < cutoff) %>%
           dplyr::group_by(query, species) %>%
           dplyr::filter(score == max(score)) %>%
           as.data.frame,
      position=position_jitter(width=0.3),
      color='red'
    ) +
    geom_hline(yintercept=-1*log10(cutoff), color='red') +
    xlab('Target species') +
    ylab('-log10(pvalue)') +
    coord_flip() +
    facet_wrap(~group)
}
@


\subsection{Mapping to known target genes}

\begin{figure}[!ht]
  \centering
<<>>=
  m <- melt_seqaln('prot2prot')
  prot2prot.cutoff <- config$prot2prot_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, prot2prot.cutoff)
@

  \caption{\textbf{Protein versus protein alignment}. Synder inferred, for each
  orphan, the genomic location where a homolog, if present, is expected to be.
  Next, for each orphan gene, the target protein coding sequences that overlap
  the search intervals were found. The focal orphan coding sequence was then
  aligned to each of these target proteins. These alignments yield raw scores,
  but no measure of statistical significance. We calculate p-values by
  simulation-based estimation of the false-positive distribution (see methods).
  \textbf{(Left)} the -log10 transformed p-values for all orphans against each
  target species (e.g. so high values are significant). \textbf{(Right)} the
  values obtained when search intervals are permuted. That is, take the links
  between orphan gene and target contexts provied by Synder, randomize them,
  then do alignment, and record the scores. The \textbf{red line} indicates the
  significance level after adjustment for multiple-testing (see methods).
  \textbf{Interpretation:} there should be few points above the past the red
  line on the right side. Any points on the left past the line indicate false
  orphans, that actually have genic counterparts that were missed in the
  initial analysis.}

\end{figure}


\subsection{Mapping to unknown ORFs on known mRNAs}
\begin{figure}[!ht]
  \centering
<<fig.width=6, fig.height=4, message=FALSE, cache=FALSE>>=
m <- lapply(results, function(x) x$features) %>%
    melt(id.vars=c('query', 'target'), level=2) %>%
    dplyr::rename(species=L2, type=L3) %>%
    dplyr::filter(type %in% c('CDS', 'mRNA', 'gene')) %>%
    dplyr::count(query, species, type) %>%
    dplyr::rename(n.feature=n) %>%
    dplyr::group_by(species, type, n.feature) %>%
    dplyr::tally()
m.zero <- m %>%
  group_by(species, type) %>%
  summarize(n=sum(n)) %>%
  mutate(
    n.feature = 0,
    n = length(query$aa) - n
  )
m2 <- rbind(m, m.zero)
ggplot(m2) +
  geom_point(aes(x=n.feature, y=n), size=0.2) +
  geom_line(aes(x=n.feature, y=n), alpha=0.05) +
  xlab('Number of overlapped features') +
  ylab('Number of search intervals') +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  ) +
  facet_grid(type~species)
@

  \caption{Number of target features overlapping a search interval. A point
  $(n,m)$ says that there are exactly $n$ search intervals that each overlap
  exactly $m$ features. A species with dots spread further to the right may
  have larger search intervals (i.e. better synteny conservation) or denser
  packing of features. This plot gives you a rough idea of how common search
  intervals that overlap lots of a particular feature are.}

\end{figure}
<<results='asis', cache=FALSE>>=
merge(
  results %>%
    lapply(function(x) nlevels(factor(x$features$CDS$query))) %>%
    lapply(function(x) sum(x %in% query$orphans)) %>%
    melt %>%
    dplyr::rename(CDS=value, species=L1),
  results %>%
    lapply(function(x) nlevels(factor(x$features$mRNA$query))) %>%
    lapply(function(x) sum(x %in% query$orphans)) %>%
    melt %>%
    dplyr::rename(mRNA=value, species=L1)
) %>% xtable(caption='Number of orphans which have at least one search intervals that overlaps at least one of the given feature.')
@

\begin{figure}[!ht]
<<>>=
  m <- melt_seqaln('prot2transorf')
  prot2transorf.cutoff <- config$prot2transorf_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, prot2transorf.cutoff)
@
  \caption{
    \textbf{Orphan genes hits against target ORFs}. All START/STOP bound open
    reading frames in the target genome were extracted. All orphan proteins
    were aligned against the ORFs that overlap one of their search intervals.
    Dots correspond to hits above \Sexpr{config$prot2allorf_minscore}.
  }
  \centering
\end{figure}


\subsection{Mapping to unknown ORFs outside known mRNAs}

\begin{figure}[!ht] \centering
<<>>=
  m <- melt_seqaln('prot2allorf')
  prot2allorf.cutoff <- config$prot2allorf_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, prot2allorf.cutoff)
@
  \caption{
    \textbf{Orphan genes hits against target ORFs}. All START/STOP bound open
    reading frames in the target genome were extracted. All orphan proteins
    were aligned against the ORFs that overlap one of their search intervals.
    Dots correspond to hits above \Sexpr{prot2allorf.cutoff}.
  }
\end{figure}


\subsection{Mapping to any DNA region in the search interval}
\begin{figure}[!ht]
  \centering
<<message=FALSE, warning=FALSE, cache=FALSE>>=
<<>>=
  m <- melt_seqaln('dna2dna')
  dna2dna.cutoff <- config$dna2dna_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, dna2dna.cutoff)
@
\caption{\
  Scores of orphan genes against their search intervals. In \textbf{sam}
  (right), the starting positions of the orphan genes were permuted while
  preserving their gene length. By chance, a few of these permuted indices may
  start on their original place, so there will be a few highscoring values.
  Dots correspond to orphans with scores above \Sexpr{dna2dna.cutoff}.
}
\end{figure}


\subsection{Find indel events}
<<results='asis', cache=FALSE>>=
results %>%
  lapply(function(x) x$ind.stats[1:2]) %>%
  melt %>%
  dplyr::rename(seqid=value, group=L2, species=L1) %>%
  dplyr::mutate(
    orphan = ifelse(seqid %in% query$orphans, 'orp', 'old'),
    group = sub('.queries', '', group)
  ) %>%
  dplyr::count(group, species, orphan) %>%
  dcast(species ~ group + orphan, mean, value.var='n') %>%
  dplyr::arrange(indeled_old, resized_old, indeled_orp, resized_orp) %>%
  dplyr::rename(
    ind_old=indeled_old, ind_orp=indeled_orp,
    res_old=resized_old, res_orp=resized_orp
  ) %>%
  xtable(
    display=c('s', 's', 'd', 'd', 'd', 'd'), 
    caption=
      'Summary of indel and resize events. A query is classified as indeled if
      at least one search interval is less than 5\\% of the length of the query.
      A query is classified as resized if at least one search interval is between
      5\\% and 100\\% the size of the query. Resize and indel events are only
      considered if the search interval is bounded (flag == 0), in which case the
      search interval length upper bounds the length of any contained homolog.
      "old" means a gene not in the orphan list, "orp" means a gene in the orphan
      list.'
  )
@


\subsection{Find queries overlapping N-strings}
<<results='asis', cache=FALSE>>=
nstring_overlappers <- results %>%
  lapply(function(x) unique(x$query2gap$query)) %>%
  (
    function(x) {x[lapply(x, is.null) %>% unlist %>% not]}
  )

# If at least one of the target species has nstring overlappers
if(length(nstring_overlappers) > 0){
nstring_overlappers %>%
  melt %>%
  dplyr::mutate(
    orphan = ifelse(value %in% query$orphans, 'orphan', 'non-orphan')
  ) %>%
  dplyr::rename(species=L1) %>%
  dplyr::count(species, orphan) %>%
  dcast(species ~ orphan, mean, value.var='n') %>%
  xtable(
    display=c('s', 's', 'd', 'd'),
    caption=
    'The number of query genes for which at least one search interval overlaps
    at least one string of Ns (unknown bases) in the target genome. These genes
    could potentially be missed in sequence searches if the target homologs are
    inside these missing regions. NOTE: it cannot be assumed that the length of
    the N-string is equal to the length of the unknown region; the true unknown
    region length is often unknown, so a stretch of 100 Ns is often inserted to
    represent the gap of unknown length. NOTE:Target species for each no search
    intervals overlaps an N-string are not represented in this table.'
  )
}
@

\subsection{Leaf labels}

<<results='asis', cache=FALSE>>=
labels$summary %>% xtable
@

\begin{figure}[!ht]
  \centering
<<classification-plot>>=
labels$summary %>%
  dplyr::group_by(species) %>%
  mutate(proportion = count / sum(count)) %>%
  ggplot(aes(description, proportion)) +
    geom_bar(aes(fill=species), stat='identity', position='dodge') +
    coord_flip()
@
  \caption{\textbf{Proportion of orphans in each sub-category}. See text for
  details on the categories.}
\end{figure}

\begin{description}
  \item[CLASS 1: Genic]
    \begin{description}

      \item[known gene] Query has strong protein sequence similarity to a known
        target protein in the search interval.

      \item[unknown ORF off known mRNA] Query has strong protein sequence
        similarity to an unannotated open reading frame (ORF), bound by a STOP
        and START codon, that is in the search interval but that is NOT on a
        region known to be transcribed.

      \item[unknown ORF on known mRNA] Query has strong protein sequence
        similarity to an unannotated ORF on a spliced mRNA (but does not match
        a known genic ORF).

    \end{description}
  \item[CLASS 2: Non-genic]
    \begin{description}

      \item[CDS in SI] One of more known coding sequences (CDS) are in the
        search interval, but there is no predicted protein sequence similarity.

      \item[mRNA but not CDS in SI] One of more transcribed regions are in the
        search interval, but no CDS.

      \item[no gene in SI] No annotated coding genes are within the search interval.

    \end{description}
  \item[CLASS 3: Unknown]
    \begin{description}

      \item[possible indel] Query maps to bounded search interval that is less
        than \Sexpr{config$indel_threshold * 100}\% the query search interval
        length AND the query maps to no other intervals.

      \item[possible N-string] The gene is of unknown origin and overlaps an
        unassembled regions (N-string).

      \item[possible resized] Query maps to bounded search interval that is
        \Sexpr{config$indel_threshold * 100}-100\% the query length. AND the
        query maps to no other intervals.  These could correspond to indels, or
        expansions in the query search interval. I distinguish between resized
        and indeled because by the most common case where the search interval
        is smaller than the query is a full deletion, where the search interval
        length is 0. The 5\% cutoff is just to allow for inaccuracies in
        alignment. The true deletions have such a strong. My gerrymandering of
        the target intervals has obfuscated the query/target relation, I may
        need to rethink this.

      \item[syntenically scrambled] The query maps to target intervals that are
        unbounded and unanchored. Error in our search space estimates is a
        likely cause for not identifying the gene.

      \item[unknown] The synteny is reliable and there is no evidence of
        indels, but there is no sequence similarity of any sort to any of the
        search intervals. This could be caused be mutation completely past
        detectability, or by undetected deletions, or by transposition of the
        gene to a new context.

    \end{description}

\end{description}

\subsection{Final Classifications}

\begin{table}[!ht]
  \centering
  \begin{tabular}{| l | c c c |}
    \hline
    leaf states & gen & non & unk \\
    \hline
    gen gen & 1 & 0 & 0 \\
    gen non & 1 & 0 & 0 \\
    gen unk & 1 & 0 & 0 \\
    non non & 0 & 1 & 0 \\
    non unk & 0 & 0 & 1 \\
    unk unk & 0 & 0 & 1 \\
    \hline
  \end{tabular}

  \caption{Inference of parent based on child leaves. Assumes a bifurcating
    tree. \textbf{gen} is genic, \textbf{non} is non-genic, and \textbf{unk} is
    unknown. 1 and 0 are ancestor asignments, e.g. if the leafs are 'gen' and
    'gen', the ancestor is classified as 'gen' (as in column 1 row 1).}

  \label{tab:label}
\end{table}

<<>>=
print(origin$root, 'gen', 'non', 'unk')
@


\newpage
\section{Appendix}

\subsection{Gumbel fitting diagnostics}

<<>>=
plot_fits <- function(group){
  for (species in names(results)){
    fit <- results[[species]][[group]]$dis$fit
    plot(fit, breaks=70)
    cat(sprintf('%s\n', species))
  }
}
@

\subsubsection{Query protein to target protein}

<<>>=
plot_fits('prot2prot')
@

\newpage
\subsubsection{Query protein to spliced ORF}

<<>>=
plot_fits('prot2transorf')
@

\newpage
\subsubsection{Query protein to any ORF}

<<>>=
plot_fits('prot2allorf')
@

\newpage
\subsubsection{Query DNA to search interval DNA}

<<>>=
plot_fits('dna2dna')
@

\subsection{Versions and parameters}

\begin{itemize}
    \item Fagin \Sexpr{get_fagin_version(config)}
    \item Synder \Sexpr{get_synder_version()}
\end{itemize}

<<dump-parameters>>=
print(config)
@

\end{document}
