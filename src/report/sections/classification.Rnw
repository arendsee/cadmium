<<cache=FALSE, message=FALSE, warning=FALSE>>=
source('~/src/git/cadmium/src/report/R/classification.R')
source('~/src/git/cadmium/src/report/R/loadData.R')
@

<<cache=TRUE, message=FALSE, warning=FALSE>>=
query <- LoadQuery(
  aafile="~/src/git/cadmium/input/faa/Arabidopsis_thaliana.faa",
  gfffile="~/src/git/cadmium/input/gff/Arabidopsis_thaliana.gff",
  orphanfile="~/src/git/cadmium/input/orphan-list.txt"
)
target <- LoadTarget(
  aafile="~/src/git/cadmium/input/faa/Arabidopsis_lyrata.faa",
  dnafile="~/src/git/cadmium/input/fna/Arabidopsis_lyrata.fna",
  sifile="~/src/git/cadmium/input/maps/Arabidopsis_thaliana.vs.Arabidopsis_lyrata.map.tab",
  synfile="~/src/git/cadmium/input/syn/Arabidopsis_thaliana.vs.Arabidopsis_lyrata.syn",
  gfffile="~/src/git/cadmium/input/gff/Arabidopsis_lyrata.gff"
)
nstring <- LoadNString('~/src/git/cadmium/input/stat/nstrings.tab')[['Arabidopsis_lyrata']]
sflags <- summarize.flags(target$si)
@

\subsection{Mapping features between GFF given scaffold}

<<>>=
origins <- initializeOrigins(query, target)
origins <- syntenicState(origins, sflags)
bittbl <- getBitTable(origins)
@

\begin{figure}[!ht]
    \centering
<<fig.width=6, fig.height=4, message=FALSE>>=
require(reshape2)
require(ggplot2)
m <- melt(
    bittbl[c('bit', 'non_orp_prop', 'orp_prop')],
    id.vars='bit',
    value.name='proportion',
    variable.name='class'
)
ggplot(m) +
    geom_point(aes(x=bit, y=proportion, color=class)) +
    geom_line(aes(x=bit, y=proportion, group=class)) +
    xlab('Synteny flags') +
    ylab('Proportion') +
    theme(
        axis.text.x = element_text(angle=270, hjust=0, vjust=1),
        legend.position=c(1, 1),
        legend.justification=c(1, 1)
    )
@
  \caption{\textbf{Synteny flags}. \textbf{(0)} the search interval is reliable;
    \textbf{(1)} the start edge is unreliable; \textbf{(2)} the stop edge is
    unreliable; \textbf{(3)} edges are unreliable, but there is overlap;
    \textbf{(4)} syntenically unreliable}.
  \label{fig:synflags}
\end{figure}



<<results='asis'>>=
require(xtable)
xtable(bittbl, caption='Nmumber of genes in each syntenic class.')
@


\subsection{Find queries that overlap target CDS}

<<cache=TRUE>>=
    cds  <- analyzeTargetFeature(query, target, feature="CDS")
    mrna <- analyzeTargetFeature(query, target, feature="mRNA")
    origins$si.overlaps.cds  <- origins$seqid %in% (cds$query2target$query %>% unique)
    origins$si.overlaps.mRNA <- origins$seqid %in% (mrna$query2target$query %>% unique)
@


<<results='asis'>>=
require(xtable)
featureCountTable(cds) %>%
  xtable(caption='Number of target CDSs overlapping one search interval')
@

<<results='asis'>>=
require(xtable)
featureCountTable(mrna) %>%
  xtable(caption='Number of target mRNAs overlapping one search interval')
@

<<>>=
n.orp.cds  <- length(unique(cds$query2target$seqid))
n.orp.mrna <- length(unique(mrna$query2target$seqid))
n.orp <- query$orphans %>% unique %>% length
@

\begin{table}[!ht]
    \centering
    \label{tab:label}
    \begin{tabular}{l | l | l}
    feature & count & percent \\ 
    \hline
    CDS  \Sexpr{n.orp.cds}  & \%\Sexpr{signif(100 * n.orp.cds  / n.orp, 2)} \\
    mRNA \Sexpr{n.orp.mrna} & \%\Sexpr{signif(100 * n.orp.mrna / n.orp, 2)} \\
    \hline
    \end{tabular}
    \caption{Number of orphans with search intervals overlapping given features}
\end{table}



\subsection{Find queries overlapping N-strings}

<<>>=
# Extract the genomeInterval object of intervals of defined size
si <- target$si$target[target$si$target %>% size %>% is.na %>% not]

# Find overlaps between search intervals and N-strings
o.n <- interval_overlap(si, nstring)
# There should be one entry in o for each feature in gff
stopifnot(length(o.n) == nrow(si))


# List of genes where at least on search interval maps to a gap
ids <- which(lapply(o.n, length) > 0)
query2gap <- o.n[ids]
ids <- rep(ids, times=lapply(query2gap, length) %>% unlist)
stopifnot(length(ids) == query2gap %>% unlist %>% length)

query2gap <- query2gap %>%
  unlist %>% 
  {
    data.frame(
      query=target$si$query$seqid[ids],
      length=size(nstring[., ])
    )
  }

  origins$si.overlaps.gap <- origins$seqid %in% query2gap$query
@

\subsection{Find protein matches}

<<>>=
  query$aa <- query$aa[origins$gene]
@

\subsection{Detect overprinting}

\subsection{Detect protein hit to ngORF}

\subsection{Find DNA hit}

\subsection{Final Classifications}

<<>>=
orp.origins <- subset(origins, orphan)

bscr <- orp.origins$scrambled %>% as.logical
bcds <- orp.origins$si.overlaps.cds %>% as.logical
brna <- orp.origins$si.overlaps.mRNA %>% as.logical

label <- ifelse(bscr, 'Scrambled', 'Unknown')
label <- ifelse(!(brna | bscr), 'Possible-intergenic', label)
label <- ifelse(bcds, 'Possibly-genic', label)
label <- ifelse(brna & !bcds, 'Possibly-intronic', label)
@

<<echo=TRUE>>=
label %>% factor %>% summary
@
