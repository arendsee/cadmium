<<message=FALSE, warning=FALSE>>=

# TODO: check all inputs, and handle missing files appropriately
# TODO: the ranges for GFFs and SI are off by 1, e.g.
# $ target$si$query[1]
# $ query$gff[which(query$gff$seqid == target$si$query[1]$seqid)]
# TODO: in Arabidopsis lyrata, at least, there are out of bound intervals

require(GenomicRanges)
require(Biostrings)
require(ggplot2)
require(reshape2)
require(scales)
require(dplyr)
require(tidyr)
require(xtable)
require(robustreg)
require(fitdistrplus)
require(ape)
require(data.tree)
require(yaml)
require(gridExtra)

source('~/src/git/fagin/src/report/R/util.R')
source('~/src/git/fagin/src/report/R/classification.R')
source('~/src/git/fagin/src/report/R/loadData.R')
source('~/src/git/fagin/src/report/R/indels.R')
source('~/src/git/fagin/src/report/R/syntenic_stats.R')
source('~/src/git/fagin/src/report/R/sequence_alignments.R')
source('~/src/git/fagin/src/report/R/feature_overlaps.R')
source('~/src/git/fagin/src/report/R/plot.R')
source('~/src/git/fagin/src/report/R/versions.R')

use_cache=TRUE
cache <- cache_factory(config)
config <- LoadConfig(configfile='~/src/git/fagin/fagin.cfg')
l_seqinfo <- LoadSeqinfoList(config)
query <- cache(LoadQuery, config, l_seqinfo)

get_results <- function(){
  results <- list()
  for(s in config$species){
    if(s %in% c(config$focal_species)){
      next
    }
    results[[s]] <- getTargetResults(
      species   = s,
      query     = query,
      config    = config,
      l_seqinfo = l_seqinfo,
      use_cache = use_cache
    )
  }
  results
}

get_model2locus_map <- function(query){
  model2locus <- query$gff %>%
    subset(type == 'mRNA') %>%
    mcols
  rownames(model2locus) <- model2locus$seqid
  model2locus <- model2locus['parent']
  model2locus
}

results <- cache(get_results)

model2locus <- get_model2locus_map(query)
labels <- determineLabels(query, results, config)
origin <- determineOrigins(labels, config)

@

\subsection{Data input}

<<echo=TRUE>>=
# number of loci in query
query$gff %>% mcols %>% subset(type == 'mRNA') %$% parent %>% unique %>% length

# number of orphans in query
model2locus[query$orphans, 'parent'] %>% unique %>% length
@


\begin{figure}[!ht]
    \centering
<<cache=TRUE, message=FALSE>>=
lapply(
  results,
  function(x){
    syn <- x$syn
    lograt <- log2(width(syn$query) / width(syn$target)[syn$query$over])
    lograt <- lograt[abs(lograt) > 0.25] 
    data.frame(
      lograt=lograt,
      index=1:length(lograt)
    )
  }
) %>% melt(id.vars=c('lograt', 'index')) %>% dplyr::rename(species=L1) %>%
ggplot +
  geom_point(aes(x=index, y=lograt), size=0.2) +
  xlab('Ordered position on query genome') +
  ylab('log2 of query to target length ratio') +
  facet_wrap(~species, scale='free_x')

@
    \caption{\textbf{Diagnostic plot of query to target lengths in synteny
        map}. The syntenic intervals on the query and target sides should
        be of similar length.  They will not be exactly the same size if gaps
        are allowed in the alignment, but wild deviation from 0 (more than,
        say, 2) indicates errors in the input. To avoid overplotting, values
        between -0.25 and 0.25 are not plotted.} 
\end{figure}


\subsection{Search interval overview}
%
Syntenic flags:
%
\begin{description}
  \item[0] the search interval is reliable
  \item[1] the start edge is unreliable
  \item[2] the stop edge is unreliable
  \item[3] both edges are unreliable, but there is an overlap
  \item[4] query is to the left of a contig, no overlap
  \item[5] query is to the right of a contig, no overlap
\end{description}

<<cache=TRUE>>=
m.syn <- lapply(results, function(x) {
  x <- x$synteny$flags
  x$seqid <- rownames(x)
  x %>%
    dplyr::group_by(seqid) %>%
    dplyr::summarize(
      A=as.logical(f0), 
      B=as.logical(f1 + f2 + f3),
      C=as.logical(f4 + f5)
    ) %>%
    with(
      data.frame(
        orphan = ifelse(seqid %in% query$orphans, 'orphan', 'non-orphan'),
        A =  A,
        B = !A &  B,
        C = !A & !B & C
      )
    ) %>%
    dplyr::group_by(orphan) %>%
    dplyr::summarize(
      A=sum(A),
      B=sum(B),
      C=sum(C)
    )
  }
) %>% melt %>% dplyr::rename(species=L1)
@
<<results='asis', cache=TRUE>>=
m.syn %>%
  group_by(orphan, species) %>%
  mutate(proportion=value/sum(value)) %>%
  dplyr::arrange(orphan, species, variable) %>%
  xtable(caption='A: numbers of genes with one or more flag==0 regions, B: !A
  and 1+ flag={1,2}, C: !A and !B and 1+ flag==3, D: else.')
@
<<fig.width=4, fig.height=4>>=
m.syn %>%
  dplyr::group_by(orphan, species) %>%
  dplyr::mutate(proportion=value/sum(value)) %>%
  dplyr::group_by(orphan, variable) %>%
  dplyr::summarize(proportion=mean(proportion)) %>%
  ggplot(aes(variable, proportion)) +
    geom_bar(aes(fill=orphan), stat='identity', position='dodge')
@

%
<<message=FALSE, cache=TRUE>>=
m <- lapply(results, function(x) x$synteny$bittbl) %>%
  lapply(dplyr::rename, orphan=orp_prop, non_orphan=non_orp_prop) %>%
  melt(id.vars='bit', value.name='proportion', variable.name='class') %>%
  subset(class %in% c('orphan', 'non_orphan')) %>%
  dplyr::rename(species=L1)
@
\begin{figure}[!ht]
    \centering
<<message=FALSE, cache=TRUE>>=
ggplot(m) +
    geom_line(aes(x=bit, y=proportion, group=class)) +
    geom_point(aes(x=bit, y=proportion, color=class)) +
    xlab('Synteny flags') +
    ylab('Proportion') +
    theme(
        axis.text.x = element_text(angle=270, hjust=0, vjust=1),
        legend.position=c(1, 1),
        legend.justification=c(1, 1)
    ) +
    facet_wrap(~species)
@
  \caption{\textbf{Synteny flags}. \textbf{(0)} the search interval is reliable;
    \textbf{(1)} the start edge is unreliable; \textbf{(2)} the stop edge is
    unreliable; \textbf{(3)} edges are unreliable, but there is overlap;
    \textbf{(4)} syntenically unreliable}.
  \label{fig:synflags}
\end{figure}
<<results='asis', cache=TRUE>>=
m %>%
  dplyr::mutate(proportion = signif(proportion * 100, 2)) %>%
  dcast(class + bit ~ species, mean, value.var='proportion') %>%
  xtable(caption=sprintf('Percent of genes in each syntenic class.'))
@
\begin{figure}[!ht]
  \centering
<<cache=TRUE, message=FALSE>>=
lapply(results, function(x) x$synteny$flags) %>%
  lapply(function(x) mutate(x, seqid=rownames(x))) %>%
  melt(id.vars='seqid') %>%
  dplyr::mutate(
    size = width(query$aa[seqid]),
    orph = ifelse(seqid %in% query$orphans, 'orphan', 'non-orphan')
  ) %>%
  dplyr::rename(flag=variable, species=L1) %>%
  subset(value > 0) %>%
  ggplot(aes(x=flag, y=size)) +
    geom_boxplot(width=0.5, notch=TRUE, outlier.size=0) +
    geom_violin(alpha=0.3) +
    facet_grid(species~orph) +
    scale_y_continuous(
      trans='log2',
      breaks=trans_breaks('log2', function(x) round(2^x))
    )
@
  \caption{\textbf{Length of genes versus syntenic flag}. Is their a
    relationship between flag class and gene length? It is reasonable that
    their would be. For example, a short interval would be less likely to be
    interupted. If the plots above suggest a meaningful difference, further
    quantitative studies may be warranted.}
  \label{fig:flag-vs-length}
\end{figure}

<<>>=
melt_seqaln <- function(field){
  m <- results %>%
    lapply(function(x) x[[field]][which(names(x[[field]]) %in% c('map', 'sam'))]) %>%
    melt(level=2, id.vars=c('score', 'pval', 'query')) %>%
    dplyr::select(-variable, -value) %>%
    dplyr::rename(group=L3, species=L2) %>%
    dplyr::group_by(query) %>%
    dplyr::filter(score == max(score)) %>%
    dplyr::filter(score > 0)
}

plot_seqaln <- function(d, cutoff){
  ggplot(d) +
    geom_violin(
      mapping=aes(x=species, y=-1*log2(pval)),
      data=m,
      alpha=0.3
    ) +
    geom_point(
      mapping=aes(x=species, y=-1*log2(pval)),
      data=subset(m, pval < cutoff) %>%
           dplyr::group_by(query, species) %>%
           dplyr::filter(score == max(score)) %>%
           as.data.frame,
      position=position_jitter(width=0.3),
      color='red'
    ) +
    geom_hline(yintercept=-1*log2(cutoff), color='red') +
    xlab('Raw alignment score (BLOSUM80)') +
    ylab('-log2(p)') +
    coord_flip() +
    facet_wrap(~group)
}
@


\subsection{Mapping to known target genes}
<<>>=
  m <- melt_seqaln('prot2prot')
  prot2prot.cutoff <- config$prot2prot_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, prot2prot.cutoff)
@


\subsection{Mapping to unknown ORFs on known mRNAs}
\begin{figure}[!ht]
  \centering
<<fig.width=6, fig.height=4, message=FALSE, cache=TRUE>>=
m <- lapply(results, function(x) x$features) %>%
    melt(id.vars=c('query', 'target'), level=2) %>%
    dplyr::rename(species=L2, type=L3) %>%
    dplyr::filter(type %in% c('CDS', 'mRNA', 'gene')) %>%
    dplyr::count(query, species, type) %>%
    dplyr::rename(n.feature=n) %>%
    dplyr::group_by(species, type, n.feature) %>%
    dplyr::tally()
m.zero <- m %>%
  group_by(species, type) %>%
  summarize(n=sum(n)) %>%
  mutate(
    n.feature = 0,
    n = length(query$aa) - n
  )
m2 <- rbind(m, m.zero)
ggplot(m2) +
  geom_point(aes(x=n.feature, y=n), size=0.2) +
  geom_line(aes(x=n.feature, y=n), alpha=0.05) +
  xlab('Number of overlapped features') +
  ylab('Number of search intervals') +
  scale_y_continuous(
    trans='log2',
    breaks=trans_breaks('log2', function(x) round(2^x))
  ) +
  facet_grid(type~species)
@
  \caption{Number of target features overlapping a search interval}
\end{figure}
<<results='asis', cache=TRUE>>=
merge(
  results %>%
    lapply(function(x) x$features$CDS$query) %>%
    lapply(unique) %>%
    lapply(length) %>%
    melt %>%
    dplyr::rename(CDS=value, species=L1),
  results %>%
    lapply(function(x) x$features$mRNA$query) %>%
    lapply(unique) %>%
    lapply(function(x) sum(x %in% query$orphans)) %>%
    melt %>%
    dplyr::rename(mRNA=value, species=L1)
) %>% xtable(caption='Number of orphans with search intervals overlapping given features')
@

\begin{figure}[!ht]
<<>>=
  m <- melt_seqaln('prot2transorf')
  prot2transorf.cutoff <- config$prot2transorf_pval / (m$query %>% unique %>% length)
  plot_seqaln(m, prot2transorf.cutoff)
@
  \caption{
    \textbf{Orphan genes hits against target ORFs}. All START/STOP bound open
    reading frames in the target genome were extracted. All orphan proteins
    were aligned against the ORFs that overlap one of their search intervals.
    Dots correspond to hits above \Sexpr{config$prot2allorf_minscore}.
  }
  \centering
\end{figure}


\subsection{Mapping to unknown ORFs outside known mRNAs}

% \begin{figure}[!ht] \centering
% <<>>=
%   m <- melt_seqaln('prot2allorf')
%   prot2allorf.cutoff <- config$prot2allorf_pval / (m$query %>% unique %>% length)
%   plot_seqaln(m, prot2allorf.cutoff)
% @
%   \caption{
%     \textbf{Orphan genes hits against target ORFs}. All START/STOP bound open
%     reading frames in the target genome were extracted. All orphan proteins
%     were aligned against the ORFs that overlap one of their search intervals.
%     Dots correspond to hits above \Sexpr{prot2allorf.cutoff}.
%   }
% \end{figure}


% \subsection{Mapping to any DNA region in the search interval}
% \begin{figure}[!ht]
%   \centering
% <<message=FALSE, warning=FALSE, cache=TRUE>>=
% <<>>=
%   m <- melt_seqaln('dna2dna')
%   dna2dna.cutoff <- config$dna2dna_pval / (m$query %>% unique %>% length)
%   plot_seqaln(m, dna2dna.cutoff)
% @
% \caption{\
%   Scores of orphan genes against their search intervals. In \textbf{ctrl}, the
%   starting positions of the orphan genes were permuted while preserving their
%   gene length. By chance, a few of these permuted indices may start on their
%   original place, so there will be a few highscoring values. Dots correspond to
%   orphans with scores above \Sexpr{dna2dna.cutoff}.
% }
% \end{figure}


\subsection{Find indel events}
<<results='asis', cache=TRUE>>=
results %>%
  lapply(function(x) x$ind.stats[1:2]) %>%
  melt %>%
  dplyr::rename(seqid=value, group=L2, species=L1) %>%
  dplyr::mutate(
    orphan = ifelse(seqid %in% query$orphans, 'orp', 'old'),
    group = sub('.queries', '', group)
  ) %>%
  dplyr::count(group, species, orphan) %>%
  dcast(species ~ group + orphan, mean, value.var='n') %>%
  dplyr::arrange(indeled_old, resized_old, indeled_orp, resized_orp) %>%
  dplyr::rename(
    ind_old=indeled_old, ind_orp=indeled_orp,
    res_old=resized_old, res_orp=resized_orp
  ) %>%
  xtable(
    display=c('s', 's', 'd', 'd', 'd', 'd'), 
    caption=
      'Summary of indel and resize events. A query is classified as indeled if at
      least one search interval is less than 5\\% of the length of the query. A
      query classified as resized if at least one search interval is between 5\\%
      and 100\\% the size of the query. Resize and indel events are only considered
      if the search interval is bounded (flag == 0), in which case the search
      interval length upper bounds the length of any contained homolog.'
  )
@


\subsection{Find queries overlapping N-strings}
<<results='asis', cache=TRUE>>=
results %>%
  lapply(function(x) unique(x$query2gap$query)) %>%
  melt %>%
  dplyr::mutate(
    orphan = ifelse(value %in% query$orphans, 'orphan', 'non-orphan')
  ) %>%
  dplyr::rename(species=L1) %>%
  dplyr::count(species, orphan) %>%
  dcast(species ~ orphan, mean, value.var='n') %>%
  xtable(
    display=c('s', 's', 'd', 'd'),
    caption=
    'The number of query genes for which at least one search interval overlaps
    at least one string of Ns (unknown bases) in the target genome. These genes
    could potentially be missed in sequence searches if the target homologs are
    inside these missing regions. NOTE: it cannot be assumed that the length of
    the N-string is equal to the length of the unknown region; the true unknown
    region length is often unknown, so a stretch of 100 Ns is often inserted to
    represent the gap of unknown length.'
  )
@

\subsection{Leaf labels}

<<results='asis', cache=TRUE>>=
labels$summary %>% xtable
@

\begin{figure}[!ht]
  \centering
<<>>=
labels$summary %>%
  dplyr::group_by(species) %>%
  mutate(proportion = count / sum(count)) %>%
  ggplot(aes(description, proportion)) +
  geom_bar(aes(fill=species), stat='identity', position='dodge') +
  coord_flip()
@
  \label{fig:}
\end{figure}

\begin{description}
  \item[CLASS 1: Genic]
    \begin{description}

      \item[known gene] Query has strong protein sequence similarity to a known
        target protein in the search interval.

      \item[unknown ORF off known mRNA] Query has strong protein sequence
        similarity to an unannotated open reading frame (ORF), bound by a STOP
        and START codon, that is in the search interval but that is NOT on a
        region known to be transcribed.

      \item[unknown ORF on known mRNA] Query has strong protein sequence
        similarity to an unannotated ORF on a spliced mRNA (but does not match
        a known genic ORF).

    \end{description}
  \item[CLASS 2: Non-genic]
    \begin{description}

      \item[CDS in SI] One of more known coding sequences (CDS) are in the
        search interval, but there is no predicted protein sequence similarity.

      \item[mRNA but not CDS in SI] One of more transcribed regions are in the
        search interval, but no CDS.

      \item[no gene in SI] No annotated coding genes are within the search interval.

      % \item[Intergenic] Query maps to no mRNAs and ALL search intervals are
      %   bounded. The query overlaps no \textit{annotated} target gene.
      %
      % \item[Possible-intergenic] Query maps to no mRNAs, but one or more search
      %   intervals is unbounded.

    \end{description}
  \item[CLASS 3: Unknown]
    \begin{description}

      \item[possible indel] Query maps to bounded search interval that is less
        than 5\% the query search interval length. AND the query maps to no other
        intervals.

      \item[possible N-string] The gene is of unknown origin and overlaps an
        unassembled regions (N-string).

      \item[possible resized] Query maps to bounded search interval that is
        5-100\% the query length. AND the query maps to no other intervals.
        These could correspond to indels, or expansions in the query search
        interval. I distinguish between resized and indeled because by the most
        common case where the search interval is smaller than the query is a
        full deletion, where the search interval length is 0. The 5\% cutoff is
        just to allow for inaccuracies in alignment. The true deletions have
        such a strong. My gerrymandering of the target intervals has obfuscated
        the query/target relation, I may need to rethink this.

      \item[syntenically scrambled] The query maps to target intervals that are
        unbounded and unanchored. Error in our search space estimates is a
        likely cause for not identifying the gene.

      \item[unknown] The synteny is reliable and there is no evidence of
        indels, but there is no sequence similarity of any sort to any of the
        search intervals. This could be caused be mutation completely past
        detectability, or by undetected deletions, or by transposition of the
        gene to a new context.

    \end{description}

\end{description}

\subsection{Final Classifications}

\begin{table}[!ht]
  \centering
  \begin{tabular}{| l | c c c |}
    \hline
    leaf states & gen & non & unk \\
    \hline
    gen gen & 1 & 0 & 0 \\
    gen non & 1 & 0 & 0 \\
    gen unk & 1 & 0 & 0 \\
    non non & 0 & 1 & 0 \\
    non unk & 0 & 0 & 1 \\
    unk unk & 0 & 0 & 1 \\
    \hline
  \end{tabular}

  \caption{Inference of parent based on child leaves. Assumes a bifurcating
    tree. \textbf{gen} is genic, \textbf{non} is non-genic, and \textbf{unk} is
    unknown. 1 and 0 are ancestor asignments, e.g. if the leafs are 'gen' and
    'gen', the ancestor is classified as 'gen' (as in column 1 row 1).}

  \label{tab:label}
\end{table}

<<>>=
print(origin$root, 'gen', 'non', 'unk')
@

<<results='asis'>>=
origin$backbone %>%
  dplyr::count(ps1, ps2, ps3) %>%
  xtable(caption='Counts of primaries labels in youngest to oldest strata')
@


% <<>>=
% a <- labels$labels %>% melt %>% dplyr::rename(species=L1, query=seqid)
% b <- results %>%
%   lapply(
%     function(x) {
%       data.frame(
%         bits=x$synteny$bits,
%         query=names(x$synteny$bits)
%       )
%     }
%   ) %>% melt %>%
%   dplyr::rename(species=L1)
% d <- merge(a, b, by=c('query', 'species')) %>%
%  merge(labels$summary[c('description', 'secondary')]) %>%
%  unique
% @
%
% <<bit-summaries>>=
% m <- split(d, d$bits) %>% lapply(function(x) x$description %>% factor %>% summary)
% @
%
% <<GGG-analysis>>=
% GGG <- origin$backbone %>%
%   subset(ps1 == 'gen' & ps2 == 'gen' & ps3=='gen') %>%
%   rownames
%
% GGG.labels <- labels$labels %>%
%   melt(id.vars=c('seqid', 'secondary'))  %>%
%   dplyr::rename(species=L1)
%
% GGG.gene.by.gene <- subset(d, query %in% GGG) %>%
%   dplyr::select(query, species, description) %>% 
%   {split(., f=factor(.$query))}
%
%   orphans <- query$orphans
%   p2p_cutoff <- config$prot2prot_pval     / length(orphans)
%   p2a_cutoff <- config$prot2allorf_pval   / length(orphans)
%   d2d_cutoff <- config$dna2dna_pval       / length(orphans)
%   p2t_cutoff <- config$prot2transorf_pval / length(orphans)
%
% # known aa seqs
% kaa <- list()
% # all ORF seqs
% oaa <- list()
% # all spliced ORF seqs
% taa <- list()
% for(s in config$species){
%   if(s == config$focal_species){
%     next
%   }
%   print(s)
%   kfile <- sprintf('%s/%s.faa', config$d_faa,       s)
%   kids <- results[[s]]$prot2prot$map     %>% subset(pval < 0.01) %$% target %>% unique
%   print(length(kids))
%   kaa[[s]] <- LoadFASTA(kfile, isAA=TRUE)[kids]
%   ofile <- sprintf('%s/%s.faa', config$d_orffaa,    s)
%   oids <- results[[s]]$prot2allorf$map   %>% subset(pval < 0.01) %$% target %>% unique
%   print(length(oids))
%   oaa[[s]] <- LoadFASTA(ofile, isAA=TRUE)[oids]
%   tfile <- sprintf('%s/%s.faa', config$d_trans_orf, s)
%   tids <- results[[s]]$prot2transorf$map %>% subset(pval < 0.01) %$% target %>% unique
%   print(length(tids))
%   taa[[s]] <- LoadFASTA(tfile, isAA=TRUE)[tids]
% }
%
% gg <- results %>%
%   lapply(function(x) x$prot2allorf$map %>% subset(pval < p2a_cutoff)) %>% 
%   melt %>%
%   dplyr::rename(species=L1) %>%
%   dplyr::select(query, target, species)
%
%   count(class) %>%
%   xtable(caption='Counts of primaries labels in youngest to oldest strata')
% @

\newpage
\section{Appendix}

\subsection{Synteny cases: the good, the bad, and the ugly}

In this subsection I will cover the cases Synder and Fagin handles goodly,
badly, and ugly. As my methods improve, cases should migrate from ugly to bad
to good.

\begin{description}

  \item[The Good] Handled exactly as I they ought to be.

  \item[The Bad] Wrong in obvious, clear-cut ways; these are nice in that they
      can probably be resolved with obvious (though possibly hard to implement)
      changes in the Synder algorithm.

  \item[The Ugly] May be 1) messy but not seriously off, 2) seriously off in
      difficult to fix ways, or 3) seriously off in ways I don't even
      understand. 

\end{description}

<<cache=TRUE>>=
load('~/src/git/fagin/cache/Arabidopsis_thaliana.vs.Arabidopsis_lyrata-LoadTarget.Rdat')
target <- out
@

\subsubsection{The Good}
\FloatBarrier

\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
  plotOne(q='AT1G01471.1', target, k=1000)
@
\caption{\textbf{Case 1: Query within a homologous region.} We nail the simplest case}
  \label{fig:good-case-1}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
  plotOne(q='AT2G31981.1', target, k=1000)
@
\caption{\textbf{Case 2a: Dulication.} Duplications and overlaps with
    extensions, no problems.}
  \label{fig:good-case-2a}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
  plotOne(q='AT2G38350.1', target, k=3000)
@
  \caption{\textbf{Case 2b: Dulications.} Weird duplication event is handled nicely.}
  \label{fig:good-case-2b}
\end{figure}
\FloatBarrier


\subsubsection{The Bad}
\FloatBarrier

\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
  plotOne(q='AT1G35320.1', target, k=10000)
@
\caption{\textbf{Case 1: strand mishandling}. (\textbf{top}) lack of strand awareness results in
    the search interval being placed on the wrong side of a block.}
  \label{fig:bad-case-1}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
  plotOne(q='AT2G47844.1', target, k=1000)
@
\caption{\textbf{Case 2: excessive extension.} Clean flag==2 case extends
    further than needed. It would be better to snap to the end of the nearest
    adjacent block.}
  \label{fig:bad-case-2}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
  plotOne(q='AT3G13403.1', target, k=1000)
@
\caption{\textbf{Case 3: double excess extension.} Clean flag==3 case extends
    further than needed. Again, snapping would be cleaner.}
  \label{fig:bad-case-3}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
  plotOne(q='AT3G04854.1', target, k=3000)
@
\caption{\textbf{Case 4: falsly imputed inversion.} incorrectly asserts an
    inversion occurred and places search interval on the wrong side
    (\textbf{search interval on right}).}
  \label{fig:bad-case-4}
\end{figure}


\subsubsection{The Ugly}
\FloatBarrier

\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT1G01073.1', target, k=1000)
@
\caption{\textbf{Case 2a: overlapping homologous regions.} Slightly overlapping
    regions split badly}
  \label{fig:ugly-case-1a}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT2G34800.1', target, k=3000)
@
\caption{\textbf{Case 2b: overlapping homologous regions.} Slightly
    overlapping(?) regions split badly}
  \label{fig:ugly-case-1b}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT3G08762.1', target, k=1000)
@
\caption{\textbf{Case 2a: adjacently overlapping.} Homologous intervals that
    overlap in both target and query.  Perhaps these should be merged, but
    there is something weird going on at the sequence level that causes this.
    Maybe they should be merged with a flag.}
  \label{fig:ugly-case-2a}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT3G18957.1', target, k=3000)
@
\caption{\textbf{Case 2b: adjacently overlapping.} Again homologous intervals
    overlapping on both sides disrupt an otherwise clean flag==0 case.}
  \label{fig:case-2b}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT3G25719.1', target, k=5000)
@
\caption{\textbf{Case 3a: insertions}. A single large insertion screws up the
    otherwise contiguous blocks. The search interval should extend past the
    insertion, clipping to the nearest block. Likewise on the target side, it
    should clip somewhere.}
  \label{fig:ugly-case-3a}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT3G42148.1', target, k=20000)
@
\caption{\textbf{Case 3a: insertions}. Double insertions and missing from main
    context (A Hardboiled Wonderland).}
  \label{fig:ugly-case-3b}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT5G56795.1', target, k=2000)
@
  \caption{\textbf{Case 3c: insertions} Multiple non-adjacent insertions.}
  \label{fig:ugly-case-3c}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT3G32120.1', target, k=10000)
@
\caption{\textbf{Case 4a: extreme distance.} There are a bunch of genes in this
    class. I think they are centromere genes.}
  \label{fig:ugly-case-4a}
\end{figure}
%
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT4G16915.1', target, k=100000)
@
  \caption{\textbf{Case 4b: extreme distance.} THIS IS SPARTA}
  \label{fig:ugly-case-4b}
\end{figure}
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
  plotOne(q='AT4G31960.1', target, k=3000)
@
\caption{\textbf{Case 5a: Borken Oddly} This looks like it should be a clean flag==0.
    Why the double search interval?}
  \label{fig:ugly-case-5a}
\end{figure}
\FloatBarrier
\begin{figure}[!ht]
  \centering
<<cache=TRUE>>=
plotOne(q='AT3G25719.1', target, k=5000)
@
  \caption{\textbf{Case 5b: Borken Oddly.} I have no idea why there is a second SI}
  \label{fig:ugly-case-5b}
\end{figure}
%


\FloatBarrier

% <<>>=
% # Non-inversed transposition
% 
% 
% # # q <- labels$labels$Arabidopsis_lyrata %>% subset(secondary == "O1") %$% seqid
%     plotOne(q[1], target, k=10000)
%     plotOne(q[2], target, k=10000)
%     plotOne(q[3], target, k=10000)
%     plotOne(q[4], target, k=10000)
%     plotOne(q[5], target, k=10000)
%     plotOne(q[6], target, k=10000)
%     plotOne(q[7], target, k=10000)
% # # q <- labels$labels$Arabidopsis_lyrata %>% subset(secondary == "O2") %$% seqid
%     plotOne(q[1], target, k=10000)
%     plotOne(q[2], target, k=10000)
%     plotOne(q[3], target, k=10000)
%     plotOne(q[4], target, k=10000)
%     plotOne(q[5], target, k=10000)
%     plotOne(q[6], target, k=10000)
%     plotOne(q[7], target, k=10000)
% @


\subsection{Gumbel fitting diagnostics}

<<>>=
require(fitdistrplus)
plot_fits <- function(group){
  for (species in names(results)){
    fit <- results[[species]][[group]]$dis$fit
    plot(fit, breaks=70)
    cat(sprintf('%s\n', species))
  }
}
@

\subsubsection{Query protein to target protein}

<<>>=
plot_fits('prot2prot')
@

\newpage
\subsubsection{Query protein to spliced ORF}

<<>>=
plot_fits('prot2transorf')
@

\newpage
\subsubsection{Query protein to any ORF}

<<>>=
plot_fits('prot2allorf')
@

\newpage
\subsubsection{Query DNA to search interval DNA}

<<>>=
plot_fits('dna2dna')
@

\subsection{Versions}

\begin{itemize}
    \item Fagin \Sexpr{get_fagin_version(config)}
    \item Synder \Sexpr{get_synder_version()}
\end{itemize}
